# Что такое типизация

**Типизация** - это фундаментальное понятие в программировании. Типизированный язык манипулирует типами данных для проверки кода на ошибки, связанные с несоответствием данных; вывода информации; выдачи подсказок в виде автодополнений внутри вашего кода. Тип данных определяет множество значений, которые может принимать переменная/функция/класс; набор операций над этой сущностью; виды переменной/функции/класса и способы взаимодействия с ними.
# Виды типизации, их особенности, плюсы и минусы
Существует 4 вида типизации языков программирования, которые могут комбинироваться друг с другом. рассмотрим каждый из них, но для начала разберем что такое этап компиляции, транспиляции и рантайм.

* **Компиляция** - преобразование программы, представленной на одном из языков программирования, в коды на машинно-ориентированном языке (в основном двоичный код), которые принимаются и исполняются непосредственно процессором (Взято с Википедии).
* **Транспиляция** - преобразование исходного кода программы, написанной на одном из языков программирования, в эквивалентный исходный код на другом языке программирования, не ломаю функциональность программы (Взято с Википедии).
* **Рантайм** (Runtime) - это программное обеспечение/инструкции, которые выполняются во время работы вашей программы, тут исполняются низкоуровневые инструкции, которые вы не написали явно, но которые необходимы для правильного выполнения и оптимизации вашего кода. По сути рантайм - это выполнение вашей программы от момента запуска до ее завершение. В рантайме могут проверяться типы данных, может происходить отладка кода и даже генерация кода.

Разобрав эти три понятия, можно переходить к разбору видов типизации:

## Слабая/Сильная (строгая/нестрогая)
Язык программирования с **сильной типизацией** не позволяет смешивать в выражениях различные типы и не выполняет автоматические неявные преобразования, например нельзя вычесть из строки число. Языки со **слабой типизацией** выполняют множество неявных преобразований автоматически, даже если может произойти потеря точности или преобразование неоднозначно. Это может приводить к неожиданным результатам вычислений. К языкам со слабой типизацией относится JavaScript. Пример слабой типизации:
```TypeScript
const a = 5;
const b = ‘word’;
console.log(a + b); // ‘5word’
```

### Преимущества сильной типизации:
* Надежность — Вы получите исключение или ошибку компиляции, взамен неправильного поведения в рантайме.
* Скорость — вместо скрытых преобразований, которые могут быть довольно затратными, с сильной типизацией необходимо писать их явно, что заставляет программиста как минимум знать, что этот участок кода может быть медленным.
* Понимание работы программы — опять-же, вместо неявного приведения типов, программист пишет все сам, а значит примерно понимает, что сравнение строки и числа происходит не само-собой и не по-волшебству.
* Определенность — когда вы пишете преобразования вручную вы точно знаете, что вы преобразуете и во что. Также вы всегда будете понимать, что такие преобразования могут привести к потере точности и к неверным результатам.

### Преимущества слабой типизации:
* Удобство использования смешанных выражений (например из целых и вещественных чисел).
* Абстрагирование от типизации и сосредоточение на задаче.
* Краткость записи.

Примеры языков с разной типизацией:
Сильная: Java, Haskell, Python;
Слабая: C, JavaScript, PHP;

## Статическая/Динамическая
В языках программирования со **статической типизацией** конечные типы переменных, функций и классов проверяются на этапе компиляции. Т.е. во время компиляции нашей программы компилятор проверяет какие типы переменных передаются в функции и классы и какие получаются на выходе, сопоставляет их друг с другом и если типы данных не конфликтуют, то он он продолжает компиляцию. В **динамической типизации** все типы вычисляются уже во время выполнения программы (в рантайме). И иногда это может сулить конфликтами между получаемыми и ожидаемыми типами данных и вызывать непредвиденные ошибки.

### Преимущества статической типизации:
* Проверки типов происходят только один раз — на этапе компиляции. А это значит, что нам не нужно будет постоянно выяснять, не пытаемся ли мы поделить число на строку (и либо выдать ошибку, либо осуществить преобразование).
* Скорость выполнения. Из предыдущего пункта ясно, что статически типизированные языки практически всегда быстрее динамически типизированных.
* При некоторых дополнительных условиях, позволяет обнаруживать потенциальные ошибки уже на этапе компиляции.
* Ускорение разработки при поддержке IDE (отсеивание вариантов, заведомо не подходящих по типу).

### Преимущества динамической типизации:
* Простота создания универсальных коллекций — куч всего и вся (редко возникает такая необходимость, но когда возникает динамическая типизация выручит).
* Удобство описания обобщенных алгоритмов (например сортировка массива, которая будет работать не только на списке целых чисел, но и на списке вещественных и даже на списке строк).
* Легкость в освоении — языки с динамической типизацией обычно очень хороши для того, чтобы начать программировать.

Примеры языков с разной типизацией:
Статическая: C, C++, Java, C#;
Динамическая: Python, JavaScript, Ruby;

## Явная/Неявная;
В языках программирования с **явной типизацией** необходимо при объявлении переменной или функции явно указать ее тип, например:
```TypeScript
const a: string = ‘TypeScript’;
const object: { name: string; age: number } = { name: ‘User’, age: 35 }
```
Ну а языки с **неявной типизацией** перекладывают эту задачу на компилятор/интерпретатор. Они самостоятельно анализируют, какого типа переменные сейчас используются и делают вывод типов на основе этого.

### Преимущества явной типизации:
* Наличие у каждой функции сигнатуры (например int add(int, int)) позволяет без проблем определить, что функция делает.
* Программист сразу записывает, какого типа значения могут храниться в конкретной переменной, что снимает необходимость запоминать это.

### Преимущества неявной типизации:
* Сокращение записи — def add(x, y) явно короче, чем int add( int x, int y).
* Устойчивость к изменениям. Например если в функции временная переменная была того-же типа, что и входной аргумент, то в явно типизированном языке при изменении типа входного аргумента нужно будет изменить еще и тип временной переменной.

Примеры языков с разной типизацией:
Явная: C#, C++;
Неявная: JavaScript, PHP;

## Структурная/Номинативная;
**Структурная типизация** определяет совместимость типов данных не основываясь на иерархии наследования, наименования или явной реализации интерфейсов, а основываясь на их описании и структуре. Два типа данных считаются эквивалентными, если  сопоставляемый тип, имеет все ключи/свойства/методы, с идентичными или совместимыми типами, что и тип с которым происходит сопоставление и наоборот. **Номинативная типизация** определяет совместимость типов данных, используя их имена, иерархии наследования и явные определения переменных. Типы данных двух переменных считаются совместимыми тогда и только тогда, когда их типы ссылаются (или наследуются) на один и тот же тип данных. Два типа данных с одинаковой структурой, но различными именами считаются различными.

Примеры языков с разной типизацией:
Структурная: TypeScripte, Rust, Scala, Lisp;
Номинативная: Java, C++, C#, SQL;