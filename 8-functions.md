# Функции

Функции - это основной строительный блок любого приложения, будь то локальные функции, функции, импортированные из другого модуля или методы класса. Они также являются значениями, и, как и другие значения, TypeScript имеет множество способов описать, как могут быть вызваны функции. Давайте узнаем, как писать типы, описывающие функции.

## Выражения типа функции (_Function Type Expressions_)

Самый простой способ описать функцию - использовать выражение типа функции. Эти типы синтаксически аналогичны стрелочным функциям:

```TypeScript
function greeter(fn: (a: string) => void) {
  fn("Hello, World");
}

function printToConsole(s: string) {
  console.log(s);
}

greeter(printToConsole);
```

Синтаксис `(a: string) => void` означает: «функция с одним параметром `a`, типа `string`, не имеющая возвращаемого значения». Как и в случае с объявлениями функций, если тип параметра не указан, он неявно имеет тип `any`.

<sub><sup>Обратите внимание, что имя параметра является обязательным. Тип функции `(string) => void` означает «функцию с параметром с именем `string` типа `any`»!</sup></sub>

Конечно, мы можем использовать псевдоним типа для обозначения типа функции:

```TypeScript
type GreetFunction = (a: string) => void;
function greeter(fn: GreetFunction) {
  // ...
}
```

## Сигнатуры вызова (_Call Signatures_)

В JavaScript функциям можно задавать свойства в дополнение к вызову самой функции. С помощью TypeScript можно описывать такие свойства используя описание типа объекта. Рассмотрим эту запутанную формулировку на примере:

```TypeScript
type DescribableFunction = {
  description: string;
  (someArg: number): boolean;
};
function doSomething(fn: DescribableFunction) {
  console.log(fn.description + " returned " + fn(6));
}
```

Обратите внимание, что синтаксис немного отличается от выражения типа функции - используйте `:` между списком параметров и типом возвращаемого значения, а не `=>`.

## Создание сигнатур (_Construct Signatures_)

Функции JavaScript также можно описывать с помощью оператора `new`. TypeScript относится к этому как к конструкторам, потому что они обычно создают новый объект. Вы можете описать сигнатуру создания функции, добавив ключевое слово `new` перед описанием сигнатуры вызова:

```TypeScript
type SomeConstructor = {
  new (s: string): SomeObject;
};
function fn(ctor: SomeConstructor) {
  return new ctor("hello");
}
```

Некоторые объекты, например объект `Date` в JavaScript, могут вызываться как с `new`, так и без него. Вы можете произвольно комбинировать вызовы и создавать сигнатуры одного типа:

```TypeScript
interface CallOrConstruct {
  new (s: string): Date;
  (n?: number): number;
}
```

## Функции дженерики (_Generic Functions_)

Так как слово generic переводится на русский с максимальной потерей контекста, то предлагаю дальше использовать данный англицизм - дженерик.

Обычно пишут функцию, в которой типы получаемых аргументов связаны с типом, возвращаемым этой функцией, или где типы нескольких аргументов каким-либо образом связаны между собой. Давайте рассмотрим функцию, которая возвращает первый элемент массива:

```TypeScript
function firstElement(arr: any[]) {
  return arr[0];
}
```

Эта функция выполняет свою работу, но она возвращает тип `any`, что не дает нам никакой информации о возвращаемом значении функции. Было бы лучше, если бы функция возвращала тип элемента массива.

```TypeScript
function firstElement<Type>(arr: Type[]): Type {
  return arr[0];
}
```

В TypeScript дженерики используются, когда мы хотим описать соответствие или зависимость между двумя значениями. Мы делаем это, объявляя параметр типа в сигнатуре функции:

```TypeScript
function firstElement<Type>(arr: Type[]): Type {
  return arr[0];
}
```

Добавив параметр типа `Type` к этой функции и используя его в двух местах, мы создали связь между входом функции (массивом) и выходом (возвращаемым значением).

```TypeScript
// s будет типа 'string'
const s = firstElement(["a", "b", "c"]);
// n будет типа 'number'
const n = firstElement([1, 2, 3]);
```

### Вывод типа (_Inference_)

Обратите внимание, что нам не нужно было указывать `Type` в примере выше. Тип был выведем автоматически TypeScript'ом.

Мы также можем использовать несколько параметров типа. Например, самописная версия функции `map` будет выглядеть так:

```TypeScript
function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {
  return arr.map(func);
}

// Параметр 'n' будет типа 'string'
// 'parsed' будет типа 'number[]'
const parsed = map(["1", "2", "3"], (n) => parseInt(n));
```

Обратите внимание, что в этом примере TypeScript может самостоятельно вывести как параметр типа `Input` (из заданного массива строк `string[]`), так и параметр типа `Output` на основе возвращаемого значения функции (`number`).

### Ограничения (_Constraints_)

Мы написали несколько функций дженериков, которые могут работать с любыми значениями. Но иногда нам необходимо ограничить область допустимых типов для дженерика.

Напишем функцию, которая возвращает большее из двух значений. Для этого нам понадобится свойство `length`, которое представляет собой число. Ограничим параметр типа с помощью ключевого слова `extends`, указав, что у аргументов функции обязательно должно быть свойство `length`:

```TypeScript
function longest<Type extends { length: number }>(a: Type, b: Type) {
  if (a.length >= b.length) {
    return a;
  } else {
    return b;
  }
}

// longerArray будет типа 'number[]'
const longerArray = longest([1, 2], [1, 2, 3]);
// longerString будет типа 'string'
const longerString = longest("alice", "bob");
// Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.
const notOK = longest(10, 100);
```

В этом примере есть несколько интересных моментов. TypeScript самостоятельно вывел возвращаемый тип функции `longest`.

Поскольку мы ограничили `Type` значением `{ length: number }`, у нас появился доступ к свойству `length` параметров `a` и `b`. Без ограничения типа мы не смогли бы получить доступ к этим свойствам, потому что типы аргументов могли бы не иметь свойства `length`.

Типы `longArray` и `longString` были выведены на основе аргументов. Помните, что дженерики связывают значения одного и того же типа!

И наконец, вызов `longest(10, 100)` вызовет ошибку, потому что тип `number` не имеет свойства `.length`.

### Работа с ограниченными значениями

Вот типичная ошибка при работе с общими ограничениями:

```TypeScript
function minimumLength<Type extends { length: number }>(
  obj: Type,
  minimum: number
): Type {
  if (obj.length >= minimum) {
    return obj;
  } else {
    return { length: minimum };
    // Type '{ length: number; }' is not assignable to type 'Type'.
    // '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.
  }
}
```

Может показаться, что с этой функцией все в порядке - `Type` ограничен значением `{ length: number }`, а функция либо возвращает `Type`, либо значение, соответствующее этому ограничению.

Проблема в том, что функция обещает вернуть тот же тип объекта, который был передан, а не просто какой-то объект, соответствующий ограничению. Если бы этот код был не выводил ошибку, вы могли бы написать код, который определенно не работал бы:

```TypeScript
// 'arr' массив получает { length: 6 }
const arr = minimumLength([1, 2, 3], 6);
// а потом приложение ломается
// потому у массивов есть метод 'slice'
// но этого метода нет у возвращаемого функцией объекта
console.log(arr.slice(0));
```

### Указание аргументов типа

TypeScript обычно может вывести аргументы предполагаемого типа в дженерике, но не всегда. Например, допустим, вы написали функцию для объединения двух массивов:

```TypeScript
function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
  return arr1.concat(arr2);
}
```

Обычно TypeScript выдает ошибку, если типы массивов не совпадают:

```TypeScript
const arr = combine([1, 2, 3], ["hello"]);
// Type 'string' is not assignable to type 'number'.
```

Однако, если вы намеревались это сделать, вы можете вручную указать `Type`:

```TypeScript
const arr = combine<string | number>([1, 2, 3], ["hello"]);
```

### Рекомендации по написанию дженерик функций

Написание общих функций - это весело, и можно легко увлечься параметризацией типов. Наличие слишком большого количества параметров типа или использование ограничений там, где они не нужны, могут сделать вывод типов менее успешным, что введет в замешательство использующих вашу функцию.

**Сдвинуть параметры типа вниз**

Вот два схожих способа написания функции:

```TypeScript
function firstElement1<Type>(arr: Type[]) {
  return arr[0];
}

function firstElement2<Type extends any[]>(arr: Type) {
  return arr[0];
}

// a: number (хорошо)
const a = firstElement1([1, 2, 3]);
// b: any (плохо)
const b = firstElement2([1, 2, 3]);
```

На первый взгляд они могут показаться идентичными, но `firstElement1` - гораздо лучший способ написать эту функцию. Ее предполагаемый возвращаемый тип - `Type`, а предполагаемый тип возвращаемого значения `firstElement2` - `any`, потому что TypeScript должен вывести тип выражения `arr[0]` с использованием типа ограничения, у него нет возможности вывести полученный тип в рантайме.

**Используйте меньше параметров типа**

Вот еще пара похожих функций:

```TypeScript
function filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {
  return arr.filter(func);
}

function filter2<Type, Func extends (arg: Type) => boolean>(
  arr: Type[],
  func: Func
): Type[] {
  return arr.filter(func);
}
```

Мы создали параметр типа `Func`, который не связывает два значения. Это плохая практика, потому что это означает, что вызывающие абоненты, указывающие аргументы типа, должны вручную указать дополнительный аргумент типа без видимой на то причины.

**Параметры типа должны появляться дважды**
Иногда мы забываем, что функция не обязательно должна быть дженериком:

```TypeScript
function greet<Str extends string>(s: Str) {
  console.log("Hello, " + s);
}

greet("world");
```

Мы могли бы так же легко написать более простую версию:

```TypeScript
function greet(s: string) {
  console.log("Hello, " + s);
}
```

Помните, что параметры типа предназначены для связи типов нескольких значений. Если параметр типа используется в сигнатуре функции только один раз, он ни с чем не связан.
