# Функции

Функции - это основной строительный блок любого приложения, будь то локальные функции, функции, импортированные из другого модуля или методы класса. Они также являются значениями, и, как и другие значения, TypeScript имеет множество способов описать, как могут быть вызваны функции. Давайте узнаем, как писать типы, описывающие функции.

## Выражения типа функции (_Function Type Expressions_)

Самый простой способ описать функцию - использовать выражение типа функции. Эти типы синтаксически аналогичны стрелочным функциям:

```TypeScript
function greeter(fn: (a: string) => void) {
  fn("Hello, World");
}

function printToConsole(s: string) {
  console.log(s);
}

greeter(printToConsole);
```

Синтаксис `(a: string) => void` означает: «функция с одним параметром `a`, типа `string`, не имеющая возвращаемого значения». Как и в случае с объявлениями функций, если тип параметра не указан, он неявно имеет тип `any`.

<sub><sup>Обратите внимание, что имя параметра является обязательным. Тип функции `(string) => void` означает «функцию с параметром с именем `string` типа `any`»!</sup></sub>

Конечно, мы можем использовать псевдоним типа для обозначения типа функции:

```TypeScript
type GreetFunction = (a: string) => void;
function greeter(fn: GreetFunction) {
  // ...
}
```

## Сигнатуры вызова (_Call Signatures_)

В JavaScript функциям можно задавать свойства в дополнение к вызову самой функции. С помощью TypeScript можно описывать такие свойства используя описание типа объекта. Рассмотрим эту запутанную формулировку на примере:

```TypeScript
type DescribableFunction = {
  description: string;
  (someArg: number): boolean;
};
function doSomething(fn: DescribableFunction) {
  console.log(fn.description + " returned " + fn(6));
}
```

Обратите внимание, что синтаксис немного отличается от выражения типа функции - используйте `:` между списком параметров и типом возвращаемого значения, а не `=>`.

## Создание сигнатур (_Construct Signatures_)

Функции JavaScript также можно описывать с помощью оператора `new`. TypeScript относится к этому как к конструкторам, потому что они обычно создают новый объект. Вы можете описать сигнатуру создания функции, добавив ключевое слово `new` перед описанием сигнатуры вызова:

```TypeScript
type SomeConstructor = {
  new (s: string): SomeObject;
};
function fn(ctor: SomeConstructor) {
  return new ctor("hello");
}
```

Некоторые объекты, например объект `Date` в JavaScript, могут вызываться как с `new`, так и без него. Вы можете произвольно комбинировать вызовы и создавать сигнатуры одного типа:

```TypeScript
interface CallOrConstruct {
  new (s: string): Date;
  (n?: number): number;
}
```

## Функции дженерики (_Generic Functions_)

Так как слово generic переводится на русский с максимальной потерей контекста, то предлагаю дальше использовать данный англицизм - дженерик.

Обычно пишут функцию, в которой типы получаемых аргументов связаны с типом, возвращаемым этой функцией, или где типы нескольких аргументов каким-либо образом связаны между собой. Давайте рассмотрим функцию, которая возвращает первый элемент массива:

```TypeScript
function firstElement(arr: any[]) {
  return arr[0];
}
```

Эта функция выполняет свою работу, но она возвращает тип `any`, что не дает нам никакой информации о возвращаемом значении функции. Было бы лучше, если бы функция возвращала тип элемента массива.

```TypeScript
function firstElement<Type>(arr: Type[]): Type {
  return arr[0];
}
```

В TypeScript дженерики используются, когда мы хотим описать соответствие или зависимость между двумя значениями. Мы делаем это, объявляя параметр типа в сигнатуре функции:

```TypeScript
function firstElement<Type>(arr: Type[]): Type {
  return arr[0];
}
```

Добавив параметр типа `Type` к этой функции и используя его в двух местах, мы создали связь между входом функции (массивом) и выходом (возвращаемым значением).

```TypeScript
// s будет типа 'string'
const s = firstElement(["a", "b", "c"]);
// n будет типа 'number'
const n = firstElement([1, 2, 3]);
```

### Вывод типа (_Inference_)

Обратите внимание, что нам не нужно было указывать `Type` в примере выше. Тип был выведем автоматически TypeScript'ом.

Мы также можем использовать несколько параметров типа. Например, самописная версия функции `map` будет выглядеть так:

```TypeScript
function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {
  return arr.map(func);
}

// Параметр 'n' будет типа 'string'
// 'parsed' будет типа 'number[]'
const parsed = map(["1", "2", "3"], (n) => parseInt(n));
```

Обратите внимание, что в этом примере TypeScript может самостоятельно вывести как параметр типа `Input` (из заданного массива строк `string[]`), так и параметр типа `Output` на основе возвращаемого значения функции (`number`).

### Ограничения (_Constraints_)

Мы написали несколько функций дженериков, которые могут работать с любыми значениями. Но иногда нам необходимо ограничить область допустимых типов для дженерика.

Напишем функцию, которая возвращает большее из двух значений. Для этого нам понадобится свойство `length`, которое представляет собой число. Ограничим параметр типа с помощью ключевого слова `extends`, указав, что у аргументов функции обязательно должно быть свойство `length`:

```TypeScript
function longest<Type extends { length: number }>(a: Type, b: Type) {
  if (a.length >= b.length) {
    return a;
  } else {
    return b;
  }
}

// longerArray будет типа 'number[]'
const longerArray = longest([1, 2], [1, 2, 3]);
// longerString будет типа 'string'
const longerString = longest("alice", "bob");
// Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.
const notOK = longest(10, 100);
```

В этом примере есть несколько интересных моментов. TypeScript самостоятельно вывел возвращаемый тип функции `longest`.

Поскольку мы ограничили `Type` значением `{ length: number }`, у нас появился доступ к свойству `length` параметров `a` и `b`. Без ограничения типа мы не смогли бы получить доступ к этим свойствам, потому что типы аргументов могли бы не иметь свойства `length`.

Типы `longArray` и `longString` были выведены на основе аргументов. Помните, что дженерики связывают значения одного и того же типа!

И наконец, вызов `longest(10, 100)` вызовет ошибку, потому что тип `number` не имеет свойства `.length`.

### Работа с ограниченными значениями

Вот типичная ошибка при работе с общими ограничениями:

```TypeScript
function minimumLength<Type extends { length: number }>(
  obj: Type,
  minimum: number
): Type {
  if (obj.length >= minimum) {
    return obj;
  } else {
    return { length: minimum };
    // Type '{ length: number; }' is not assignable to type 'Type'.
    // '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.
  }
}
```

Может показаться, что с этой функцией все в порядке - `Type` ограничен значением `{ length: number }`, а функция либо возвращает `Type`, либо значение, соответствующее этому ограничению.

Проблема в том, что функция обещает вернуть тот же тип объекта, который был передан, а не просто какой-то объект, соответствующий ограничению. Если бы этот код был не выводил ошибку, вы могли бы написать код, который определенно не работал бы:

```TypeScript
// 'arr' массив получает { length: 6 }
const arr = minimumLength([1, 2, 3], 6);
// а потом приложение ломается
// потому у массивов есть метод 'slice'
// но этого метода нет у возвращаемого функцией объекта
console.log(arr.slice(0));
```

### Указание аргументов типа

TypeScript обычно может вывести аргументы предполагаемого типа в дженерике, но не всегда. Например, допустим, вы написали функцию для объединения двух массивов:

```TypeScript
function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
  return arr1.concat(arr2);
}
```

Обычно TypeScript выдает ошибку, если типы массивов не совпадают:

```TypeScript
const arr = combine([1, 2, 3], ["hello"]);
// Type 'string' is not assignable to type 'number'.
```

Однако, если вы намеревались это сделать, вы можете вручную указать `Type`:

```TypeScript
const arr = combine<string | number>([1, 2, 3], ["hello"]);
```

### Рекомендации по написанию дженерик функций

Написание общих функций - это весело, и можно легко увлечься параметризацией типов. Наличие слишком большого количества параметров типа или использование ограничений там, где они не нужны, могут сделать вывод типов менее успешным, что введет в замешательство использующих вашу функцию.

**Сдвинуть параметры типа вниз**

Вот два схожих способа написания функции:

```TypeScript
function firstElement1<Type>(arr: Type[]) {
  return arr[0];
}

function firstElement2<Type extends any[]>(arr: Type) {
  return arr[0];
}

// a: number (хорошо)
const a = firstElement1([1, 2, 3]);
// b: any (плохо)
const b = firstElement2([1, 2, 3]);
```

На первый взгляд они могут показаться идентичными, но `firstElement1` - гораздо лучший способ написать эту функцию. Ее предполагаемый возвращаемый тип - `Type`, а предполагаемый тип возвращаемого значения `firstElement2` - `any`, потому что TypeScript должен вывести тип выражения `arr[0]` с использованием типа ограничения, у него нет возможности вывести полученный тип в рантайме.

**Используйте меньше параметров типа**

Вот еще пара похожих функций:

```TypeScript
function filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {
  return arr.filter(func);
}

function filter2<Type, Func extends (arg: Type) => boolean>(
  arr: Type[],
  func: Func
): Type[] {
  return arr.filter(func);
}
```

Мы создали параметр типа `Func`, который не связывает два значения. Это плохая практика, потому что это означает, что вызывающие абоненты, указывающие аргументы типа, должны вручную указать дополнительный аргумент типа без видимой на то причины.

**Параметры типа должны появляться дважды**
Иногда мы забываем, что функция не обязательно должна быть дженериком:

```TypeScript
function greet<Str extends string>(s: Str) {
  console.log("Hello, " + s);
}

greet("world");
```

Мы могли бы так же легко написать более простую версию:

```TypeScript
function greet(s: string) {
  console.log("Hello, " + s);
}
```

Помните, что параметры типа предназначены для связи типов нескольких значений. Если параметр типа используется в сигнатуре функции только один раз, он ни с чем не связан.

## Необязательные параметры (_Optional Parameters_)

Функции в JavaScript часто принимают переменное количество аргументов. Например, метод числа `toFixed` принимает необязательный счетчик цифр:

```TypeScript
function f(n: number) {
  console.log(n.toFixed()); // 0 аргументов
  console.log(n.toFixed(3)); // 1 аргумент
}
```

Мы можем смоделировать это в TypeScript, пометив параметр как необязательный с помощью `?`:

```TypeScript
function f(x?: number) {
  // ...
}
f(); // OK
f(10); // OK
```

Хотя параметр указан как тип `number`, параметр `x` фактически будет иметь тип `number | undefined`, потому что неуказанные параметры в JavaScript получают значение `undefined`.
Вы также можете указать параметр по умолчанию:

```TypeScript
function f(x = 10) {
  // ...
}
```

Теперь в теле функции `f`, `x` будет иметь тип `number`, потому что любой неопределенный аргумент будет заменен на `10`. Обратите внимание, что когда параметр является необязательным, вызывающие эту функцию всегда могут передать `undefined`, поскольку это просто имитирует «отсутствующий» аргумент:

```TypeScript
declare function f(x?: number): void;
// cut
// All OK
f();
f(10);
f(undefined);
```

## Необязательные параметры в обратных вызовах(_Optional Parameters in Callbacks_)

Узнав о необязательных параметрах и выражениях типов функций, очень легко сделать следующие ошибки при написании функций, использующих обратные вызовы (колбэки):

```TypeScript
function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i);
  }
}
```

Что люди обычно имеют в виду, когда пишут `index?` в качестве необязательного параметра? они хотят, чтобы оба этих вызова были верными:

```TypeScript
myForEach([1, 2, 3], (a) => console.log(a));
myForEach([1, 2, 3], (a, i) => console.log(a, i));
```

На самом деле это означает, что обратный вызов может быть вызван с одним аргументом. Другими словами, в определении функции сказано, что реализация может выглядеть так:

```TypeScript
function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
  for (let i = 0; i < arr.length; i++) {
    // В этот раз индекс сюда не передается
    callback(arr[i]);
  }
}
```

В свою очередь TypeScript может отлавливать ошибки, связанные с обращением к переменным, которые могут быть `undefined` и, по сути, заставляет проверять, не равна ли переменная `undefined`:

```TypeScript
myForEach([1, 2, 3], (a, i) => {
  console.log(i.toFixed());
  // Object is possibly 'undefined'.
});
```

## Перегрузка функций (_Function Overloads_)

Некоторые функции JavaScript могут вызываться с разным количеством аргументов и разными типами. Например, вы можете написать функцию для создания даты `Date`, которая принимает либо метку времени (один аргумент), либо спецификацию месяца/дня/года (три аргумента).

В TypeScript мы можем указать функцию, которую можно вызывать по-разному, записывая сигнатуры перегрузки. Для этого напишите некоторое количество сигнатур функции (обычно две или более), а затем тело функции:

```TypeScript
function makeDate(timestamp: number): Date;
function makeDate(m: number, d: number, y: number): Date;
function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
  if (d !== undefined && y !== undefined) {
    return new Date(y, mOrTimestamp, d);
  } else {
    return new Date(mOrTimestamp);
  }
}
const d1 = makeDate(12345678);
const d2 = makeDate(5, 5, 5);
const d3 = makeDate(1, 3);
// No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.
```

В этом примере мы написали две перегрузки: одна принимает один аргумент, а другая принимает три аргумента. Эти первые две сигнатуры называются сигнатурами перегрузки.

Затем мы написали реализацию функции с совместимой сигнатурой. У функций есть сигнатура реализации, но эта сигнатура не может быть вызвана напрямую. Несмотря на то, что мы написали функцию с двумя необязательными параметрами после обязательного, ее нельзя вызвать с двумя параметрами!

### Сигнатура перегрузки и сигнатура реализации

В этом моменте очень часто происходит путаница. Люди пишут такой код и не понимают, почему возникает ошибка:

```TypeScript
function fn(x: string): void;
function fn() {
  // ...
}
// Ожидается, что функцию можно вызывать без аргументов
// но получаем ошибку
fn();
// Expected 1 arguments, but got 0.
```

Сигнатура тела функции должна быть описана последней. То есть эта сигнатура не видна при использовании функции, потому что она должна комбинировать в себе реализацию сигнатур, описанных над ней.

Сигнатура реализации также должна быть совместима с сигнатурами перегрузки. Например, в этих функциях есть ошибки, потому что сигнатура реализации неправильно соответствует перегрузкам:

```TypeScript
function fn(x: boolean): void;
// Тип аргумента не верный
function fn(x: string): void;
function fn(x: boolean) {}
// This overload signature is not compatible with its implementation signature.
```

```TypeScript
function fn(x: string): string;
// Возвращаемый тип не верный
function fn(x: number): boolean;
function fn(x: string | number) {
  // This overload signature is not compatible with its implementation signature.
  return "oops";
}
```

### Написание хороших перегрузок

Как и в случае с дженериками, есть несколько рекомендаций, которым вы должны следовать при использовании перегрузок функций. Следование этим принципам упростит вызов функции, ее понимание и реализацию.

Давайте рассмотрим функцию, которая возвращает длину строки или массива:

```TypeScript
function len(s: string): number;
function len(arr: any[]): number;
function len(x: any) {
  return x.length;
}
```

Эта функция работает правильно; мы можем вызывать ее со строками или массивами. Однако мы не можем вызвать ее со значением, которое может быть строкой или массивом `s: string | any[]`, потому что TypeScript может разрешить вызов функции только для одной перегрузки:

```TypeScript
len(""); // OK
len([0]); // OK
len(Math.random() > 0.5 ? "hello" : [0]);
// No overload matches this call.
//  Overload 1 of 2, '(s: string): number', gave the following error.
//    Argument of type 'number[] | "hello"' is not assignable to parameter of type 'string'.
//      Type 'number[]' is not assignable to type 'string'.
//  Overload 2 of 2, '(arr: any[]): number', gave the following error.
///    Argument of type 'number[] | "hello"' is not assignable to parameter of type 'any[]'.
//      Type 'string' is not assignable to type 'any[]'.
```

Поскольку обе перегрузки имеют одинаковое количество аргументов и один и тот же тип возвращаемого значения, мы можем вместо этого написать неперегруженную версию функции:

```TypeScript
function len(x: any[] | string) {
  return x.length;
}
```

Так намного лучше! Теперь мы можем вызывать функцию с любым значением, и в качестве дополнительного бонуса нам не нужно вычислять правильную сигнатуру реализации.

### Объявление this в функции

TypeScript самостоятельно определяет, каким должен быть `this` в функции, с помощью анализа кода. Например:

```TypeScript
const user = {
  id: 123,

  admin: false,
  becomeAdmin: function () {
    this.admin = true;
  },
};
```

TypeScript понимает, что функция `user.becomeAdmin` имеет соответствующий `this`, который является внешним объектом `user`. `this` обычно достаточно для управления объектом, но бывают моменты, когда вам нужно больше контроля над тем объектом, который представляет `this`.

В спецификации JavaScript указано, что у вас не может быть параметра с именем `this`, и поэтому TypeScript использует это пространство синтаксиса, чтобы вы могли объявить тип для `this` в теле функции.

```TypeScript
interface DB {
  filterUsers(filter: (this: User) => boolean): User[];
}

const db = getDB();
const admins = db.filterUsers(function () {
  return this.isAdmin;
});
```

Этот шаблон обратного вызова, который применяется для использования сторонних API, где другой объект обычно управляет вызовом вашей функции. Обратите внимание, что вам нужно использовать обычный вызов функции. Стрелочные функции выдают ошибку, при обращении к `this`:

```TypeScript
const db = getDB();
const admins = db.filterUsers(() => this.isAdmin);
// The containing arrow function captures the global value of 'this'.
// Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.
```

## Другие типы, о которых нужно знать

Есть некоторые дополнительные типы, которые часто используются при работе с типами функций. Как и все типы, вы можете использовать их везде, но они особенно актуальны в контексте функций.

### void

`void` описывает возвращаемое значение функций, которые не возвращают значения. Данный тип выводится тогда, когда функция не имеет операторов `return` или не возвращает явного значения из этих операторов:

```TypeScript
// Возвращаемый функцией тип равен void
function noop() {
  return;
}
```

В JavaScript функция, не возвращающая никакого значения, неявно возвращает значение `undefined`. Однако `void` и `undefined` - это не одно и то же в TypeScript. См. Справочную страницу [Почему `void` - особый тип] для более подробного обсуждения этого вопроса.

<sub><sup>`void` - это не то же самое, что и `undefined`.</sup></sub>

### object

Тип `object` относится к любому значению, не являющемуся примитивом (`string`, `number`, `boolean`, `symbol`, `null` или `undefined`). Он отличается от типа пустого объекта `{}`, а также от глобального типа `Object`. Вы можете прочитать справочную страницу [[Глобальные типы]] для получения информации о том, для чего нужен `Object` - короче говоря, никогда не используйте `Object`.

<sub><sup>`object` не является `Object`. **Всегда** используйте `object`!</sup></sub>

Обратите внимание, что в JavaScript значения функции являются объектами: у них есть свойства, есть `Object.prototype` в их цепочке прототипов, они являются `instanceof Object`, вы можете вызывать для них `Object.keys` и так далее. По этой причине типы функций считаются объектами `objects` и в TypeScript.

### unknown

`unknown` тип представляет любое значение. Он похоже на тип `any`, но безопаснее, потому что делать что-либо со сущность типа `unknown` нельзя:

```TypeScript
function f1(a: any) {
  a.b(); // OK
}

function f2(a: unknown) {
  a.b();
  // Object is of type 'unknown'.
}
```

Это полезно при описании типов функций, поскольку вы можете описывать функции, которые принимают любое значение, но в теле функции не будет типов `any`. И наоборот, вы можете описать функцию, которая возвращает значение неизвестного типа:

```TypeScript
function safeParse(s: string): unknown {
  return JSON.parse(s);
}

// Будьте осторожны с переменной 'obj'!
const obj = safeParse(someRandomString);
```

### never

Некоторые функции никогда не возвращают значение:

```TypeScript
function fail(msg: string): never {
  throw new Error(msg);
}
```

Тип `never` представляет значения, которые никогда не используются. В возвращаемом типе это означает, что функция вызывает исключение или прекращает выполнение программы.

`never` также появляется, когда TypeScript определяет, что в объединении ничего не осталось.

```TypeScript
function fn(x: string | number) {
  if (typeof x === "string") {
    // Выполняем если 'x' строка
  } else if (typeof x === "number") {
    // Выполняем если 'x' число
  } else {
    x; // Является типом 'never'!
  }
}
```

### Function

Глобальный тип `Function` описывает такие свойства, как `bind`, `call`, `apply` и т.д., присутствующие во всех значениях функций в JavaScript.

Он также имеет специальное свойство, которое позволяет всегда вызывать значения типа Function; эти вызовы возвращают тип `any`:

```TypeScript
function doSomething(f: Function) {
  f(1, 2, 3);
}
```

Это нетипизированный вызов функции, и его обычно лучше избегать из-за небезопасного возвращаемого типа `any`.

Если нужно принять произвольную функцию, обычно безопаснее использовать тип `() => void`.

## Остальные (оставшиеся) параметры и аргументы (_Rest Parameters and Arguments_)

### Остальные параметры (_Rest Parameters_)

В дополнение к использованию необязательных параметров или перегрузок для создания функций, которые могут принимать множество фиксированных значений аргументов, мы также можем определять функции, которые принимают неограниченное количество аргументов, используя остальные параметры.

Параметр `rest` появляется после всех остальных параметров и использует синтаксис `...`:

```TypeScript
function multiply(n: number, ...m: number[]) {
  return m.map((x) => n * x);
}
// 'a' gets value [10, 20, 30, 40]
const a = multiply(10, 1, 2, 3, 4);
```
