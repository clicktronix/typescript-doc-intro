# Функции

Функции - это основной строительный блок любого приложения, будь то локальные функции, функции, импортированные из другого модуля или методы класса. Они также являются значениями, и, как и другие значения, TypeScript имеет множество способов описать, как могут быть вызваны функции. Давайте узнаем, как писать типы, описывающие функции.

## Выражения типа функции (_Function Type Expressions_)

Самый простой способ описать функцию - использовать выражение типа функции. Эти типы синтаксически аналогичны стрелочным функциям:

```TypeScript
function greeter(fn: (a: string) => void) {
  fn("Hello, World");
}

function printToConsole(s: string) {
  console.log(s);
}

greeter(printToConsole);
```

Синтаксис `(a: string) => void` означает: «функция с одним параметром `a`, типа `string`, не имеющая возвращаемого значения». Как и в случае с объявлениями функций, если тип параметра не указан, он неявно имеет тип `any`.

<sub><sup>Обратите внимание, что имя параметра является обязательным. Тип функции `(string) => void` означает «функцию с параметром с именем `string` типа `any`»!</sup></sub>

Конечно, мы можем использовать псевдоним типа для обозначения типа функции:

```TypeScript
type GreetFunction = (a: string) => void;
function greeter(fn: GreetFunction) {
  // ...
}
```

## Сигнатуры вызова (_Call Signatures_)

В JavaScript функциям можно задавать свойства в дополнение к вызову самой функции. С помощью TypeScript можно описывать такие свойства используя описание типа объекта. Рассмотрим эту запутанную формулировку на примере:

```TypeScript
type DescribableFunction = {
  description: string;
  (someArg: number): boolean;
};
function doSomething(fn: DescribableFunction) {
  console.log(fn.description + " returned " + fn(6));
}
```

Обратите внимание, что синтаксис немного отличается от выражения типа функции - используйте `:` между списком параметров и типом возвращаемого значения, а не `=>`.

## Создание сигнатур (_Construct Signatures_)

Функции JavaScript также можно описывать с помощью оператора `new`. TypeScript относится к этому как к конструкторам, потому что они обычно создают новый объект. Вы можете описать сигнатуру создания функции, добавив ключевое слово `new` перед описанием сигнатуры вызова:

```TypeScript
type SomeConstructor = {
  new (s: string): SomeObject;
};
function fn(ctor: SomeConstructor) {
  return new ctor("hello");
}
```

Некоторые объекты, например объект `Date` в JavaScript, могут вызываться как с `new`, так и без него. Вы можете произвольно комбинировать вызовы и создавать сигнатуры одного типа:

```TypeScript
interface CallOrConstruct {
  new (s: string): Date;
  (n?: number): number;
}
```

## Функции дженерики (_Generic Functions_)

Так как слово generic переводится на русский с максимальной потерей контекста, то предлагаю дальше использовать данный англицизм - дженерик.

Обычно пишут функцию, в которой типы получаемых аргументов связаны с типом, возвращаемым этой функцией, или где типы нескольких аргументов каким-либо образом связаны между собой. Давайте рассмотрим функцию, которая возвращает первый элемент массива:

```TypeScript
function firstElement(arr: any[]) {
  return arr[0];
}
```

Эта функция выполняет свою работу, но она возвращает тип `any`, что не дает нам никакой информации о возвращаемом значении функции. Было бы лучше, если бы функция возвращала тип элемента массива.

```TypeScript
function firstElement<Type>(arr: Type[]): Type {
  return arr[0];
}
```

В TypeScript дженерики используются, когда мы хотим описать соответствие или зависимость между двумя значениями. Мы делаем это, объявляя параметр типа в сигнатуре функции:

```TypeScript
function firstElement<Type>(arr: Type[]): Type {
  return arr[0];
}
```

Добавив параметр типа `Type` к этой функции и используя его в двух местах, мы создали связь между входом функции (массивом) и выходом (возвращаемым значением).

```TypeScript
// s будет типа 'string'
const s = firstElement(["a", "b", "c"]);
// n будет типа 'number'
const n = firstElement([1, 2, 3]);
```

### Вывод типа (_Inference_)

Обратите внимание, что нам не нужно было указывать `Type` в примере выше. Тип был выведем автоматически TypeScript'ом.

Мы также можем использовать несколько параметров типа. Например, самописная версия функции `map` будет выглядеть так:

```TypeScript
function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {
  return arr.map(func);
}

// Параметр 'n' будет типа 'string'
// 'parsed' будет типа 'number[]'
const parsed = map(["1", "2", "3"], (n) => parseInt(n));
```

Обратите внимание, что в этом примере TypeScript может самостоятельно вывести как параметр типа `Input` (из заданного массива строк `string[]`), так и параметр типа `Output` на основе возвращаемого значения функции (`number`).

### Ограничения (_Constraints_)

Мы написали несколько функций дженериков, которые могут работать с любыми значениями. Но иногда нам необходимо ограничить область допустимых типов для дженерика.

Напишем функцию, которая возвращает большее из двух значений. Для этого нам понадобится свойство `length`, которое представляет собой число. Ограничим параметр типа с помощью ключевого слова `extends`, указав, что у аргументов функции обязательно должно быть свойство `length`:

```TypeScript
function longest<Type extends { length: number }>(a: Type, b: Type) {
  if (a.length >= b.length) {
    return a;
  } else {
    return b;
  }
}

// longerArray будет типа 'number[]'
const longerArray = longest([1, 2], [1, 2, 3]);
// longerString будет типа 'string'
const longerString = longest("alice", "bob");
// Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.
const notOK = longest(10, 100);
```

В этом примере есть несколько интересных моментов. TypeScript самостоятельно вывел возвращаемый тип функции `longest`.

Поскольку мы ограничили `Type` значением `{ length: number }`, у нас появился доступ к свойству `length` параметров `a` и `b`. Без ограничения типа мы не смогли бы получить доступ к этим свойствам, потому что типы аргументов могли бы не иметь свойства `length`.

Типы `longArray` и `longString` были выведены на основе аргументов. Помните, что дженерики связывают значения одного и того же типа!

И наконец, вызов `longest(10, 100)` вызовет ошибку, потому что тип `number` не имеет свойства `.length`.

### Работа с ограниченными значениями

Вот типичная ошибка при работе с общими ограничениями:

```TypeScript
function minimumLength<Type extends { length: number }>(
  obj: Type,
  minimum: number
): Type {
  if (obj.length >= minimum) {
    return obj;
  } else {
    return { length: minimum };
    // Type '{ length: number; }' is not assignable to type 'Type'.
    // '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.
  }
}
```

Может показаться, что с этой функцией все в порядке - `Type` ограничен значением `{ length: number }`, а функция либо возвращает `Type`, либо значение, соответствующее этому ограничению.

Проблема в том, что функция обещает вернуть тот же тип объекта, который был передан, а не просто какой-то объект, соответствующий ограничению. Если бы этот код был не выводил ошибку, вы могли бы написать код, который определенно не работал бы:

```TypeScript
// 'arr' массив получает { length: 6 }
const arr = minimumLength([1, 2, 3], 6);
// а потом приложение ломается
// потому у массивов есть метод 'slice'
// но этого метода нет у возвращаемого функцией объекта
console.log(arr.slice(0));
```

### Указание аргументов типа

TypeScript обычно может вывести аргументы предполагаемого типа в дженерике, но не всегда. Например, допустим, вы написали функцию для объединения двух массивов:

```TypeScript
function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
  return arr1.concat(arr2);
}
```

Обычно TypeScript выдает ошибку, если типы массивов не совпадают:

```TypeScript
const arr = combine([1, 2, 3], ["hello"]);
// Type 'string' is not assignable to type 'number'.
```

Однако, если вы намеревались это сделать, вы можете вручную указать `Type`:

```TypeScript
const arr = combine<string | number>([1, 2, 3], ["hello"]);
```

### Рекомендации по написанию дженерик функций

Написание общих функций - это весело, и можно легко увлечься параметризацией типов. Наличие слишком большого количества параметров типа или использование ограничений там, где они не нужны, могут сделать вывод типов менее успешным, что введет в замешательство использующих вашу функцию.

**Сдвинуть параметры типа вниз**

Вот два схожих способа написания функции:

```TypeScript
function firstElement1<Type>(arr: Type[]) {
  return arr[0];
}

function firstElement2<Type extends any[]>(arr: Type) {
  return arr[0];
}

// a: number (хорошо)
const a = firstElement1([1, 2, 3]);
// b: any (плохо)
const b = firstElement2([1, 2, 3]);
```

На первый взгляд они могут показаться идентичными, но `firstElement1` - гораздо лучший способ написать эту функцию. Ее предполагаемый возвращаемый тип - `Type`, а предполагаемый тип возвращаемого значения `firstElement2` - `any`, потому что TypeScript должен вывести тип выражения `arr[0]` с использованием типа ограничения, у него нет возможности вывести полученный тип в рантайме.

**Используйте меньше параметров типа**

Вот еще пара похожих функций:

```TypeScript
function filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {
  return arr.filter(func);
}

function filter2<Type, Func extends (arg: Type) => boolean>(
  arr: Type[],
  func: Func
): Type[] {
  return arr.filter(func);
}
```

Мы создали параметр типа `Func`, который не связывает два значения. Это плохая практика, потому что это означает, что вызывающие абоненты, указывающие аргументы типа, должны вручную указать дополнительный аргумент типа без видимой на то причины.

**Параметры типа должны появляться дважды**
Иногда мы забываем, что функция не обязательно должна быть дженериком:

```TypeScript
function greet<Str extends string>(s: Str) {
  console.log("Hello, " + s);
}

greet("world");
```

Мы могли бы так же легко написать более простую версию:

```TypeScript
function greet(s: string) {
  console.log("Hello, " + s);
}
```

Помните, что параметры типа предназначены для связи типов нескольких значений. Если параметр типа используется в сигнатуре функции только один раз, он ни с чем не связан.

## Необязательные параметры (_Optional Parameters_)

Функции в JavaScript часто принимают переменное количество аргументов. Например, метод числа `toFixed` принимает необязательный счетчик цифр:

```TypeScript
function f(n: number) {
  console.log(n.toFixed()); // 0 аргументов
  console.log(n.toFixed(3)); // 1 аргумент
}
```

Мы можем смоделировать это в TypeScript, пометив параметр как необязательный с помощью `?`:

```TypeScript
function f(x?: number) {
  // ...
}
f(); // OK
f(10); // OK
```

Хотя параметр указан как тип `number`, параметр `x` фактически будет иметь тип `number | undefined`, потому что неуказанные параметры в JavaScript получают значение `undefined`.
Вы также можете указать параметр по умолчанию:

```TypeScript
function f(x = 10) {
  // ...
}
```

Теперь в теле функции `f`, `x` будет иметь тип `number`, потому что любой неопределенный аргумент будет заменен на `10`. Обратите внимание, что когда параметр является необязательным, вызывающие эту функцию всегда могут передать `undefined`, поскольку это просто имитирует «отсутствующий» аргумент:

```TypeScript
declare function f(x?: number): void;
// cut
// All OK
f();
f(10);
f(undefined);
```

## Необязательные параметры в обратных вызовах(_Optional Parameters in Callbacks_)

Узнав о необязательных параметрах и выражениях типов функций, очень легко сделать следующие ошибки при написании функций, использующих обратные вызовы (колбэки):

```TypeScript
function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i);
  }
}
```

Что люди обычно имеют в виду, когда пишут `index?` в качестве необязательного параметра? они хотят, чтобы оба этих вызова были верными:

```TypeScript
myForEach([1, 2, 3], (a) => console.log(a));
myForEach([1, 2, 3], (a, i) => console.log(a, i));
```

На самом деле это означает, что обратный вызов может быть вызван с одним аргументом. Другими словами, в определении функции сказано, что реализация может выглядеть так:

```TypeScript
function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
  for (let i = 0; i < arr.length; i++) {
    // В этот раз индекс сюда не передается
    callback(arr[i]);
  }
}
```

В свою очередь TypeScript может отлавливать ошибки, связанные с обращением к переменным, которые могут быть `undefined` и, по сути, заставляет проверять, не равна ли переменная `undefined`:

```TypeScript
myForEach([1, 2, 3], (a, i) => {
  console.log(i.toFixed());
  // Object is possibly 'undefined'.
});
```

## Перегрузка функций (_Function Overloads_)

Некоторые функции JavaScript могут вызываться с разным количеством аргументов и разными типами. Например, вы можете написать функцию для создания даты `Date`, которая принимает либо метку времени (один аргумент), либо спецификацию месяца/дня/года (три аргумента).

В TypeScript мы можем указать функцию, которую можно вызывать по-разному, записывая сигнатуры перегрузки. Для этого напишите некоторое количество сигнатур функции (обычно две или более), а затем тело функции:

```TypeScript
function makeDate(timestamp: number): Date;
function makeDate(m: number, d: number, y: number): Date;
function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
  if (d !== undefined && y !== undefined) {
    return new Date(y, mOrTimestamp, d);
  } else {
    return new Date(mOrTimestamp);
  }
}
const d1 = makeDate(12345678);
const d2 = makeDate(5, 5, 5);
const d3 = makeDate(1, 3);
// No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.
```

В этом примере мы написали две перегрузки: одна принимает один аргумент, а другая принимает три аргумента. Эти первые две сигнатуры называются сигнатурами перегрузки.

Затем мы написали реализацию функции с совместимой сигнатурой. У функций есть сигнатура реализации, но эта сигнатура не может быть вызвана напрямую. Несмотря на то, что мы написали функцию с двумя необязательными параметрами после обязательного, ее нельзя вызвать с двумя параметрами!

### Сигнатура перегрузки и сигнатура реализации

В этом моменте очень часто происходит путаница. Люди пишут такой код и не понимают, почему возникает ошибка:

```TypeScript
function fn(x: string): void;
function fn() {
  // ...
}
// Ожидается, что функцию можно вызывать без аргументов
// но получаем ошибку
fn();
// Expected 1 arguments, but got 0.
```

Сигнатура тела функции должна быть описана последней, то есть эта сигнатура не видна при использовании функции
