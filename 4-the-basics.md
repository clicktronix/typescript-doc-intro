# Основы TypeScript

Каждое значение в JavaScript имеет набор поведения, которое вы можете наблюдать при выполнении различных операций. Это звучит абстрактно, но в качестве быстрого примера рассмотрим некоторые операции, которые мы можем запустить с переменной с именем `message`.
```TypeScript
// Получаем доступ к свойству 'toLowerCase' и вызываем его
message.toLowerCase();
// Вызываем 'message'
message();
```
Если мы разберем это, первая исполняемая строчка кода получит доступ к свойству с именем `toLowerCase`, а затем вызовет его. Второй пытается вызвать `message` напрямую.

Но если предположить, что мы не знаем значения `message` - а это довольно часто - мы не можем достоверно сказать, какие результаты мы получим, пытаясь запустить какой-либо из этих кодов. Поведение каждой операции полностью зависит от того, какое значение у нас было изначально.
* можно ли вызвать `message`?
* есть ли у него свойство `toLowerCase`?
* если да, можно ли вызвать `toLowerCase`?
* если оба этих значения можно вызвать то, что они возвращают?
Ответы на эти вопросы обычно остаются в голове, когда мы пишем JavaScript, и мы должны надеяться, что правильно учли все детали.

Допустим `message` определено таким способом:
```TypeScript
const message = "Hello World!";

// Код из примера выше
message.toLowerCase();
message();
```
Как можно догадаться, если мы попытаемся запустить `message.toLowerCase()`, мы получим ту же строку только в нижнем регистре.

А что насчет второй строчки кода? Если вы знакомы с JavaScript, то наверняка знаете, что это не так, за исключением:
```TypeScript
TypeError: message is not a function
```
Было бы здорово, если бы мы смогли избежать подобных ошибок.

Когда мы запускаем наш код, среда выполнения JavaScript выбирает, что делать, путем определения типа значения - типа поведения и возможностей, которыми оно обладает. Это часть того, на что ссылается этот `TypeError` - он говорит, что строка «Hello World» не может быть вызвана как функция.

Для некоторых значений, таких примитивов как `string` и `number`, мы можем определить их тип во время рантайма с помощью оператора `typeof`. Но для других вещей, таких как функции, нет соответствующего рантайм механизма для определения их типов. Например, рассмотрим эту функцию:
```TypeScript
function fn(x) {
  return x.flip();
}
```
Посмотрев на этот код, мы можем заметить, что эта функция будет работать, только если дан объект с вызываемым свойством `flip`, но JavaScript не отображает эту информацию таким образом, чтобы мы могли проверить ее во время выполнения кода. В чистом JavaScript единственный способ узнать, что `fn` делает с определенным значением, - это вызвать его и посмотреть, что произойдет. Такое поведение затрудняет прогнозирование того, что будет делать код до его запуска, а это значит, что сложнее понять, что будет делать ваш код, пока вы его пишете.

С этой точки зрения тип - это концепция описания того, какие значения могут быть переданы в fn, а какие будут аварийно завершены. JavaScript действительно обеспечивает только динамическую типизацию - запуск кода, чтобы увидеть, что происходит.

Альтернативой является использование системы статических типов для прогнозирования ожидаемого кода перед его запуском.

## Статическая типизация
Вспомните ошибку `TypeError`, которую мы получили ранее при попытке вызвать строку `string` как функцию. Большинство людей не любят получать какие-либо ошибки при запуске своего кода - они считаются багами! И когда мы пишем новый код, мы изо всех сил стараемся избегать появления новых ошибок.

Если мы добавим немного кода, сохраним наш файл, повторно запустим код и сразу же увидим ошибку, мы сможем быстро изолировать проблему; но это не всегда так. Возможно, мы не проверили эту функцию достаточно тщательно, поэтому мы никогда не столкнемся с потенциальной ошибкой, которая может возникнуть! Или, если бы нам посчастливилось стать свидетелями ошибки, мы могли бы провести большой рефакторинг и добавить много другого кода, который нам пришлось бы копаться.

В идеале у нас может быть инструмент, который поможет нам найти эти ошибки до запуска нашего кода. Это то, что делает статическая проверка типов, такая как TypeScript. Системы статических типов описывают формы и поведение наших ценностей при запуске наших программ. Средство проверки типов, такое как TypeScript, использует эту информацию и сообщает нам, когда что-то может пойти не так.
```TypeScript
const message = "hello!";

message();

// This expression is not callable. Type 'String' has no call signatures.
```
Запуск этого последнего примера с TypeScript даст нам сообщение об ошибке, прежде чем мы запустим код в первую очередь.

## Скрытые ошибки

До сих пор мы обсуждали некоторые вещи, такие как ошибки времени выполнения - случаи, когда среда выполнения JavaScript сообщает нам, что считает что-то бессмысленным. Эти случаи возникают из-за того, что спецификация [ECMAScript](https://tc39.es/ecma262/) содержит явные инструкции о том, как язык должен вести себя, когда он сталкивается с чем-то неожиданным.

Например, в спецификации сказано, что попытка вызвать что-то, что нельзя вызвать, должна вызывать ошибку. Может быть, это звучит как «очевидное поведение», но вы можете представить, что доступ к свойству, которого не существует для объекта, также должен вызывать ошибку. Вместо этого JavaScript дает нам другое поведение и возвращает значение undefined:
```TypeScript
const user = {
  name: "Daniel",
  age: 26,
};
user.location; // вернет undefined
```
В конечном счете, система статического типа должна решить, какой код должен быть помечен как ошибка в ее системе, даже если это «действительный» JavaScript, который не сразу выдаст ошибку. В TypeScript следующий код вызывает ошибку о том, что `location` не определено:
```TypeScript
const user = {
  name: "Daniel",
  age: 26,
};

user.location;
// Property 'location' does not exist on type '{ name: string; age: number; }'.
```
Хотя иногда это подразумевает компромисс в том, что вы можете выразить, цель состоит в том, чтобы отловить законные ошибки в наших программах. И TypeScript отлавливает множество законных ошибок.

Например: опечатки,
```TypeScript
const announcement = "Hello World!";

// Как быстро вы сможете обнаружить опечатки?
announcement.toLocaleLowercase();
announcement.toLocalLowerCase();

// Скорее всего мы имели ввиду это...
announcement.toLocaleLowerCase();
```
невызванные функции,
```TypeScript
function flipCoin() {
  // Должно быть Math.random()
  return Math.random < 0.5;
  // Оператор '<' нельзя применить к '() => number'.
}
```
или основные логические ошибки.
```TypeScript
const value = Math.random() < 0.5 ? "a" : "b";
if (value !== "a") {
  // ...
} else if (value === "b") {
  // This condition will always return 'false' since the types '"a"' and '"b"' have no overlap.
  // Это условие всегда будет возвращать 'false' поскольку типы '"a"' и '"b"' не пересекаются.
  // Этот блок кода никогда не выполнится
}
```

## Типы как инструмент
TypeScript может обнаруживать ошибки, когда мы делаем ошибки в нашем коде. Это замечательно, но TypeScript может в первую очередь уберечь нас от этих ошибок.

Средство проверки типов содержит информацию, позволяющую проверять, например, получаем ли мы доступ к нужным свойствам переменных и другим свойствам. Получив эту информацию, он также может начать предлагать, какие свойства вы, возможно, захотите использовать.

Это означает, что TypeScript можно использовать и для редактирования кода, а основная программа проверки типов может выдавать сообщения об ошибках и автозавершение кода при вводе текста в редакторе. Это часть того, что люди часто имеют в виду, когда говорят об инструментах TypeScript.

![alt autosuggest](./images/autosuggest.png?raw=true "Autosuggest")

TypeScript серьезно относится к инструментам, и это выходит за рамки дополнений и ошибок при вводе. Редактор кода, поддерживающий TypeScript, может предоставлять «быстрые исправления» для автоматического исправления ошибок, рефакторинг для легкой реорганизации кода и полезные функции навигации для перехода к определениям переменной или поиска всех ссылок на данную переменную. Все это построено на основе проверки типов и является полностью кроссплатформенным, поэтому вполне вероятно, что ваш любимый редактор кода поддерживает TypeScript.

## tsc, компилятор TypeScript
Мы говорили о проверке типов, но еще не использовали этот инструмент. Давайте познакомимся с нашим новым другом `tsc`, компилятором TypeScript. Сначала нам нужно получить его через `npm`.
```
npm install -g typescript
```

<sub><sup>Это установит TypeScript компилятор `tsc` глобально. Вы можете использовать `npx` или аналогичные инструменты, если вместо этого предпочитаете запускать `tsc` из локального пакета `node_modules`.</sup></sub>

Теперь перейдем в пустую папку и попробуем написать нашу первую программу на TypeScript: `hello.ts`:
```TypeScript
// Выведем в консоль приветствие
console.log("Hello world!");
```
Заметьте, здесь нет никаких излишеств; эта программа «hello world» выглядит идентично тому, что вы написали бы для программы «hello world» на JavaScript. А теперь давайте проверим его тип, выполнив команду ], которая была установлена ​​для нас пакетом `typescript`.
```
tsc hello.ts
```
Мы запустили `tsc` и ничего не произошло! Что ж, ошибок типа не было, поэтому мы не получили никаких результатов в нашей консоли, так как не о чем было сообщать.

Но проверьте еще раз - вместо этого мы получили файл. Если мы заглянем в наш текущий каталог, мы увидим файл `hello.js` рядом с `hello.ts`. Это результат работы нашего файла `hello.ts` после того, как `tsc` скомпилирует или преобразует его в простой файл JavaScript. И если мы проверим содержимое, мы увидим, что выдаст TypeScript после обработки файла `.ts`: