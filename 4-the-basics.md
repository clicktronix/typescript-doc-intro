# Основы TypeScript

Каждое значение в JavaScript имеет набор поведений, которые вы можете наблюдать при выполнении различных операций. Это звучит абстрактно, но в качестве быстрого примера рассмотрим некоторые операции, которые мы можем запустить с переменной с именем `message`.

```TypeScript
// Получаем доступ к свойству 'toLowerCase' и вызываем его
message.toLowerCase();
// Вызываем 'message'
message();
```

Первая исполняемая строчка кода получит доступ к свойству с именем `toLowerCase`, а затем вызовет его. На второй строчке мы пытаемся вызвать `message` напрямую.

Если предположить, что мы не знаем значения `message` - а мы довольно частно не можем достоверно сказать, какие значения мы получим, пытаясь запустить какой-либо из этих кодов. Поведение каждой операции полностью зависит от того, какое значение у нас было в `message` изначально.

- можно ли вызвать `message`?
- есть ли у него свойство `toLowerCase`?
- если да, можно ли вызвать `toLowerCase`?
- если оба этих значения можно вызвать то, что они возвращают?
  Ответы на эти вопросы обычно всегда приходится держать в голове, когда мы пишем на JavaScript, и мы должны надеяться, что правильно учли все детали.

Допустим `message` определено таким способом:

```TypeScript
const message = "Hello World!";

// Код из примера выше
message.toLowerCase();
message();
```

Как можно догадаться, если мы попытаемся запустить `message.toLowerCase()`, мы получим ту же строку только в нижнем регистре.

А что насчет второй строчки кода? Если вы знакомы с JavaScript, то наверняка знаете, что этот код не сработает и мы получим ошибку:

```TypeScript
TypeError: message is not a function
```

Было бы здорово, если бы мы смогли избежать подобных ошибок.

Когда мы запускаем наш код, среда выполнения JavaScript выбирает, что делать, путем определения типа значения - каким поведением он обладает, какие методы и свойства у него есть. И при проверке кода выше мы получаем `TypeError` - говорящий, что строка `"Hello World"` не может быть вызвана как функция.

Для некоторых значений таких примитивов как `string` и `number`, мы можем определить их тип во время рантайма с помощью оператора `typeof`. Но для других вещей, таких как функции, нет соответствующего рантайм механизма для определения их типов. Например, рассмотрим эту функцию:

```TypeScript
function fn(x) {
  return x.flip();
}
```

Посмотрев на этот код, мы можем заметить, что эта функция будет работать, только если передан объект с вызываемым свойством `flip`, но JavaScript не отображает эту информацию таким образом, чтобы мы могли проверить ее во время написания кода. В чистом JavaScript единственный способ узнать, что `fn` делает с определенным значением, - это вызвать его и посмотреть, что произойдет. Такое поведение затрудняет прогнозирование того, что будет делать код до его запуска, а это, в свою очередь, усложняет и замедляет написание кода.

С этой точки зрения тип - это концепция описания того, какие значения могут быть переданы в `fn`, а какие поломают нашу программу. JavaScript обеспечивает только динамическую типизацию - запуск кода, чтобы увидеть, что происходит и какой аргумент получила наша функция.

Альтернативой является использование системы статических типов для прогнозирования ожидаемого поведения кода перед его запуском.

## Статическая типизация

Вспомните ошибку `TypeError`, которую мы получили ранее при попытке вызвать строку `string` как функцию. Полагаю большинство людей не любит получать какие-либо ошибки при запуске своего кода. И когда мы пишем новый код, мы изо всех сил стараемся избегать появления новых ошибок.

Если мы добавим немного нового кода, сохраним наш файл, повторно его запустим и сразу же увидим ошибку, мы сможем быстро изолировать проблему (так как держим в голове последние изменения и можем примерно представить где ошиблись); но это не всегда так. Бывают моменты, когда мы не достаточно оттестировали поведение функции, она ушла в продакшн и ошибку поймали только спустя время. За это время наша функция разрослась и чтобы произвести правки этой ошибки, нам необходимо изменить очень много кода.

В идеале у нас должен быть инструмент, который поможет нам найти эти ошибки до запуска нашего кода. Это то, что делает статическая проверка типов, такая как TypeScript. Системы статических типов описывают формы сущностей, их поведение и то, какими они должны быть еще до запуска нашей программы. Средство проверки типов, такое как TypeScript, использует эти описания типов и сообщает нам, когда что-то может пойти не так.

```TypeScript
const message = "hello!";

message();

// This expression is not callable. Type 'String' has no call signatures.
```

Запуск этого последнего примера с TypeScript выдаст нам сообщение об ошибке прежде, чем мы запустим код.

## Скрытые ошибки

До сих пор мы обсуждали ошибки рантайма - случаи, когда среда выполнения JavaScript сообщает нам, что что-то пошло не так. Эти случаи возникают из-за того, что спецификация [ECMAScript](https://tc39.es/ecma262/) содержит явные инструкции о том, как язык должен вести себя, когда он сталкивается с чем-то неожиданным.

Например, в спецификации сказано, что попытка вызвать что-то, что нельзя вызвать, должна выдавать ошибку. Звучит как «очевидное поведение», но бывает и такое поведение: доступ к свойству объекта, которого не существует, также должен выдавать ошибку, место этого JavaScript дает нам другое поведение и возвращает значение undefined:

```TypeScript
const user = {
  name: "Daniel",
  age: 26,
};
user.location; // вернет undefined
```

В этом случае, система статической типизации помечает внутри компилятора код, в котором произошла ошибка, даже если это «работающий» JavaScript, который не выдает ошибку.

В TypeScript следующий код вызывает ошибку о том, что `location` не определено:

```TypeScript
const user = {
  name: "Daniel",
  age: 26,
};

user.location;
// Property 'location' does not exist on type '{ name: string; age: number; }'.
```

TypeScript позволяет отлавливать множество различных типов ошибок до запуска проекта, не только свойства, которые не определены.

Например: опечатки,

```TypeScript
const announcement = "Hello World!";

// Как быстро вы сможете обнаружить опечатки?
announcement.toLocaleLowercase();
announcement.toLocalLowerCase();

// Скорее всего мы имели ввиду это...
announcement.toLocaleLowerCase();
```

невызванные функции,

```TypeScript
function flipCoin() {
  // Должно быть Math.random()
  return Math.random < 0.5;
  // Оператор '<' нельзя применить к '() => number'.
}
```

или логические ошибки.

```TypeScript
const value = Math.random() < 0.5 ? "a" : "b";
if (value !== "a") {
  // ...
} else if (value === "b") {
  // This condition will always return 'false' since the types '"a"' and '"b"' have no overlap.
  // Это условие всегда будет возвращать 'false' поскольку типы '"a"' и '"b"' не пересекаются.
  // Этот блок кода никогда не выполнится
}
```

## Типы как инструмент

С помощью инструментов TypeScript можно частично обезопасить себя от опечаток или вызова не верных методов.

Средство проверки типов содержит информацию, позволяющую проверить, например, доступ к нужным свойствам объекта или их наличие. Получив эту информацию, он также может начать предлагать, какие свойства мы можем использовать.

Это означает, что TypeScript можно использовать и для редактирования кода, а система проверки типов может выдавать сообщения об ошибках и автодополнения кода при вводе текста в редакторе. Это часть того, что люди часто имеют в виду, когда говорят об инструментах TypeScript.

![alt autosuggest](./images/autosuggest.png?raw=true "Autosuggest")

TypeScript серьезно относится к инструментам, и это выходит за рамки автодополнений и показа ошибок при вводе. Редактор кода, поддерживающий TypeScript, может предоставлять «быстрые исправления» для автоматического исправления ошибок, возможность рефакторинга кода и полезные функции навигации для перехода к определениям переменных или поиска всех ссылок на данную переменную. Все это построено на основе проверки типов и является полностью кроссплатформенным.

## tsc, компилятор TypeScript

Мы говорили о проверке типов, но еще не использовали этот инструмент. Давайте познакомимся с товарищем `tsc`, компилятором TypeScript. Сначала нам нужно получить его через `npm`.

```
npm install -g typescript
```

<sub><sup>Это установит TypeScript компилятор `tsc` глобально. Вы можете использовать `npx` или аналогичные инструменты, если вместо этого предпочитаете запускать `tsc` из локального пакета `node_modules`.</sup></sub>

Теперь перейдем в пустую папку и попробуем написать нашу первую программу на TypeScript: `hello.ts`:

```TypeScript
// Выведем в консоль приветствие
console.log("Hello world!");
```

Заметьте, здесь нет никаких излишеств; эта программа «hello world» выглядит идентично тому, что вы написали бы для программы «hello world» на JavaScript. А теперь давайте проверим его тип, выполнив команду, которая была установлена ​​для нас пакетом `typescript`.

```
tsc hello.ts
```

Мы запустили `tsc` и ничего не произошло! Что ж, ошибок типа не было, поэтому мы не получили никаких результатов в нашей консоли, так как не о чем было сообщать.

Но проверьте еще раз - мы получили новый файл. Если мы заглянем в наш текущий каталог, мы увидим файл `hello.js` рядом с `hello.ts`. Это результат работы нашего файла `hello.ts` после того, как `tsc` скомпилирует или преобразует его в простой файл JavaScript. И если мы проверим содержимое, мы увидим, что выдаст TypeScript после обработки файла `.ts`:

```TypeScript
// Выведем в консоль приветствие
console.log("Hello world!");
```

В этом случае было слишком мало кода, чтобы TypeScript произвел какие-либо преобразования, поэтому он выглядит идентично тому, что мы написали. Компилятор пытается создать чистый читаемый код, который выглядит так, как будто что-то написал бы человек. Хотя это не всегда так просто, TypeScript делает отступы единообразно, учитывает написание кода на разных строчках и пытается сохранить форматирование и комментарии.

А что насчет того, чтобы мы ввели ошибку проверки типов? Перепишем `hello.ts`:

```TypeScript
// Обычная функция приветствия
function greet(person, date) {
  console.log(`Hello ${person}, today is ${date}!`);
}

greet("Brendan");
```

Если мы снова запустим `tsc hello.ts`, обратите внимание, что мы получим ошибку в командной строке!

```TypeScript
Expected 2 arguments, but got 1.
```

TypeScript сообщает нам, что мы забыли передать аргумент в функцию `greet`, и это правильно. Пока что мы написали только стандартный JavaScript, но проверка типов все же смогла найти проблемы с нашим кодом. Спасибо, TypeScript!

### Вывод ошибок

Одна вещь, которую вы могли не заметить из последнего примера, - это то, что наш файл `hello.js` снова изменился. Если мы откроем этот файл, то увидим, что его содержимое в основном выглядит так же, как и наш входной файл. Это может быть немного удивительно, учитывая тот факт, что `tsc` сообщил об ошибке в нашем коде, но код все равно транспилировался в `.js`. Странно, ведь была ошибка, почему код все равно выполнился? Это зависит от того, насколько строго компилятор `tsc` будет обрабатывать наш код.

Процесс проверки типов вводит ограничения на разработку и запуск программ. Поэтому существует компромисс (_tradeoff_) между тем, какие типы после проверки будут сочтены приемлемыми, а за какими последует ошибка. В большинстве случаев это нормально, но есть сценарии, когда эти проверки мешают. Например, представьте, что вы переносите код JavaScript на TypeScript и описываете типы для ваших сущностей. В процессе переписывания проекта на TypeScript у нас, скорее всего, возникнет необходимость запустить наш проект, но тут могут возникнуть ошибки типов! При текущей конфигурации компилятор `tsc` проинформирует нас о наличии ошибок, но все равно скомпилирует наш код в JS, ведь он работал ранее без типизации, почему он должен перестать работать с ней?

Но такой подход не гарантирует нам безопасности в типах нашей программы. Поэтому для тех, кому нужен более защищенный от ошибок код, TypeScript может действовать немного строже. Для этого можно использовать параметр компилятора `--noEmitOnError`. Который запрещает компиляцию файлов в JavaScript, пока у нас есть ошибки в типах. Попробуйте изменить свой файл `hello.ts` и запустить `tsc` с этим флагом:

```
tsc --noEmitOnError hello.ts
```

Вы заметите, что `hello.js` никогда не обновляется.

## Явные типы

До сих пор мы не сообщали TypeScript, что такое `person` или `data`. Давайте отредактируем код, чтобы сообщить TypeScript, что `person` - это `string`, а `date` является объектом `Date`. Мы также будем использовать метод `toDateString()` для `date`.

```TypeScript
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}
```

Что мы сделали, так это добавили аннотации типов к `person` и `date`, чтобы описать, с какими типами значений можно вызывать `greet`. Мы читаем сигнатуру функции `greet` как "`greet` принимает аргумент `person` типа `string` и аргумент `date` типа `Date`".

Благодаря этому TypeScript может оповещать нас о том, что мы вызываем функцию неправильно, например, если мы передаем аргументы с несопоставимым типом:

```TypeScript
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

greet("Maddison", Date());
// Argument of type 'string' is not assignable to parameter of type 'Date'.
```

TypeScript сообщил об ошибке во втором аргументе, но почему?

Как ни странно, вызов `Date()` в JavaScript возвращает строку. С другой стороны, создание `Date` с помощью `new Date()` фактически возвращает нам то, что мы ожидали.

В любом случае, мы можем быстро исправить ошибку:

```TypeScript
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

greet("Maddison", new Date());
```

Имейте в виду, что нам не всегда нужно писать явные аннотации типов. Во многих случаях TypeScript может просто вывести (_infer_) или вычислить типы за нас, даже если мы их опустим.

```TypeScript
let msg = "hello there!";
//  ^ = let msg: string
```

Несмотря на то, что мы не сообщили TypeScript, что у `msg` есть тип `string`, он смог это выяснить. Это фича TypeScript, и лучше не добавлять аннотации, если система типов может вывести их самостоятельно. Это добавляет большей гибкости нашему коду.

## Удаленные типы

Давайте посмотрим, что происходит, когда мы компилируем вышеуказанную функцию `greet` в JavaScript, с помощью `tsc` :

```JavaScript
"use strict";
function greet(person, date) {
    console.log("Hello " + person + ", today is " + date.toDateString() + "!");
}
greet("Maddison", new Date());
```

Обратите внимание на две вещи:

- Наши параметры `person` и `date` больше не имеют аннотаций типов.
- Наша «шаблонная строка» - та строка, в которой использовались обратные кавычки (символ `) - была преобразована в простые строки с помощью конкатенации (+).

Подробнее об этом втором пункте позже, а теперь давайте сосредоточимся на первом. Аннотации типов не являются частью JavaScript (если точнее то ECMAScript), поэтому на самом деле нет браузеров или других сред выполнения, которые могли бы просто запускать TypeScript без изменений. Вот почему TypeScript в первую очередь нужен компилятор - ему нужен способ вырезать или преобразовать любой код, специфичный для TypeScript, чтобы вы могли его запустить в среде выполнения. Большая часть кода, специфичного для TypeScript, стирается, а также стираются аннотации типов.

**Помните: аннотации типов никогда не меняют поведение вашей программы в рантайме.**

## Снижение версии

Еще одно отличие от приведенного выше заключалось в том, что наша строка шаблона была переписана с:

```TypeScript
`Hello ${person}, today is ${date.toDateString()}!`;
```

на:

```TypeScript
"Hello " + person + ", today is " + date.toDateString() + "!";
```

Почему это случилось?

Шаблонные строки - это функционал, добавленный в ECMAScript 2015 (также известной как ECMAScript 6, ES2015, ES6 и т. д.). TypeScript имеет возможность переписывать код из более новых версий ECMAScript в более старые, такие как ECMAScript 3 или ECMAScript 5 (также известные как ES3 и ES5). Этот процесс перехода от новой или «более высокой» версии ECMAScript к более старой или «более низкой» иногда называют понижением уровня (_downleveling_).

По умолчанию TypeScript компилирует в версию ES3, очень старую версию ECMAScript. Мы могли бы выбрать что-то более свежее, используя флаг `--target`. Запуск с `--target es2015` изменяет изменяет экспортируемую версию JavaScript на ECMAScript2015, что означает, что код должен работать везде, где поддерживается ECMAScript2015. Таким образом, запуск `tsc --target es2015 input.ts` дает нам следующий результат:

```JavaScript
function greet(person, date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}
greet("Maddison", new Date());
```

<sub><sup>Хотя целью по умолчанию является ES3, подавляющее большинство текущих браузеров поддерживают ES2015. Поэтому большинство разработчиков могут безопасно указать ES2015 или более позднюю версию в качестве цели, если не важна совместимость с некоторыми старыми браузерами.</sup></sub>
