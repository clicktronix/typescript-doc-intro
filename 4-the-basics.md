# Основы TypeScript

Каждое значение в JavaScript имеет набор поведений, которые вы можете наблюдать при выполнении различных операций. Это звучит абстрактно, но в качестве быстрого примера рассмотрим некоторые операции, которые мы можем запустить с переменной с именем `message`.
```TypeScript
// Получаем доступ к свойству 'toLowerCase' и вызываем его
message.toLowerCase();
// Вызываем 'message'
message();
```
Первая исполняемая строчка кода получит доступ к свойству с именем `toLowerCase`, а затем вызовет его. На второй строчке мы пытаемся вызвать `message` напрямую.

Если предположить, что мы не знаем значения `message` - а мы довольно частно не можем достоверно сказать, какие значения мы получим, пытаясь запустить какой-либо из этих кодов. Поведение каждой операции полностью зависит от того, какое значение у нас было в `message` изначально.
* можно ли вызвать `message`?
* есть ли у него свойство `toLowerCase`?
* если да, можно ли вызвать `toLowerCase`?
* если оба этих значения можно вызвать то, что они возвращают?
Ответы на эти вопросы обычно всегда приходится держать в голове, когда мы пишем на JavaScript, и мы должны надеяться, что правильно учли все детали.

Допустим `message` определено таким способом:
```TypeScript
const message = "Hello World!";

// Код из примера выше
message.toLowerCase();
message();
```
Как можно догадаться, если мы попытаемся запустить `message.toLowerCase()`, мы получим ту же строку только в нижнем регистре.

А что насчет второй строчки кода? Если вы знакомы с JavaScript, то наверняка знаете, что этот код не сработает и мы получим ошибку:
```TypeScript
TypeError: message is not a function
```
Было бы здорово, если бы мы смогли избежать подобных ошибок.

Когда мы запускаем наш код, среда выполнения JavaScript выбирает, что делать, путем определения типа значения - каким поведением он обладает, какие методы и свойства у него есть. И при проверке кода выше мы получаем `TypeError` - говорящий, что строка `"Hello World"` не может быть вызвана как функция.

Для некоторых значений таких примитивов как `string` и `number`, мы можем определить их тип во время рантайма с помощью оператора `typeof`. Но для других вещей, таких как функции, нет соответствующего рантайм механизма для определения их типов. Например, рассмотрим эту функцию:
```TypeScript
function fn(x) {
  return x.flip();
}
```
Посмотрев на этот код, мы можем заметить, что эта функция будет работать, только если передан объект с вызываемым свойством `flip`, но JavaScript не отображает эту информацию таким образом, чтобы мы могли проверить ее во время написания кода. В чистом JavaScript единственный способ узнать, что `fn` делает с определенным значением, - это вызвать его и посмотреть, что произойдет. Такое поведение затрудняет прогнозирование того, что будет делать код до его запуска, а это, в свою очередь, усложняет и замедляет написание кода.

С этой точки зрения тип - это концепция описания того, какие значения могут быть переданы в `fn`, а какие поломают нашу программу. JavaScript обеспечивает только динамическую типизацию - запуск кода, чтобы увидеть, что происходит и какой аргумент получила наша функция.

Альтернативой является использование системы статических типов для прогнозирования ожидаемого поведения кода перед его запуском.

## Статическая типизация
Вспомните ошибку `TypeError`, которую мы получили ранее при попытке вызвать строку `string` как функцию. Полагаю большинство людей не любит получать какие-либо ошибки при запуске своего кода. И когда мы пишем новый код, мы изо всех сил стараемся избегать появления новых ошибок.

Если мы добавим немного нового кода, сохраним наш файл, повторно его запустим и сразу же увидим ошибку, мы сможем быстро изолировать проблему (так как держим в голове последние изменения и можем примерно представить где ошиблись); но это не всегда так. Бывают моменты, когда мы не достаточно оттестировали поведение функции, она ушла в продакшн и ошибку поймали только спустя время. За это время наша функция разрослась и чтобы произвести  правки этой ошибки, нам необходимо изменить очень много кода.

В идеале у нас должен быть инструмент, который поможет нам найти эти ошибки до запуска нашего кода. Это то, что делает статическая проверка типов, такая как TypeScript. Системы статических типов описывают формы, поведение сущностей и то, какими они должны быть еще до запуска нашей программы. Средство проверки типов, такое как TypeScript, использует эти описания типов и сообщает нам, когда что-то может пойти не так.
```TypeScript
const message = "hello!";

message();

// This expression is not callable. Type 'String' has no call signatures.
```
Запуск этого последнего примера с TypeScript выдаст нам сообщение об ошибке прежде, чем мы запустим код.

## Скрытые ошибки

До сих пор мы обсуждали ошибки рантайма - случаи, когда среда выполнения JavaScript сообщает нам, что считает что-то бессмысленным. Эти случаи возникают из-за того, что спецификация [ECMAScript](https://tc39.es/ecma262/) содержит явные инструкции о том, как язык должен вести себя, когда он сталкивается с чем-то неожиданным.

Например, в спецификации сказано, что попытка вызвать что-то, что нельзя вызвать, должна вызывать ошибку. Может быть, это звучит как «очевидное поведение», но вы можете представить, что доступ к свойству, которого не существует для объекта, также должен вызывать ошибку. Вместо этого JavaScript дает нам другое поведение и возвращает значение undefined:
```TypeScript
const user = {
  name: "Daniel",
  age: 26,
};
user.location; // вернет undefined
```
В конечном счете, система статического типа должна решить, какой код должен быть помечен как ошибка в ее системе, даже если это «действительный» JavaScript, который не сразу выдаст ошибку. В TypeScript следующий код вызывает ошибку о том, что `location` не определено:
```TypeScript
const user = {
  name: "Daniel",
  age: 26,
};

user.location;
// Property 'location' does not exist on type '{ name: string; age: number; }'.
```
Хотя иногда это подразумевает компромисс в том, что вы можете выразить, цель состоит в том, чтобы отловить законные ошибки в наших программах. И TypeScript отлавливает множество законных ошибок.

Например: опечатки,
```TypeScript
const announcement = "Hello World!";

// Как быстро вы сможете обнаружить опечатки?
announcement.toLocaleLowercase();
announcement.toLocalLowerCase();

// Скорее всего мы имели ввиду это...
announcement.toLocaleLowerCase();
```
невызванные функции,
```TypeScript
function flipCoin() {
  // Должно быть Math.random()
  return Math.random < 0.5;
  // Оператор '<' нельзя применить к '() => number'.
}
```
или основные логические ошибки.
```TypeScript
const value = Math.random() < 0.5 ? "a" : "b";
if (value !== "a") {
  // ...
} else if (value === "b") {
  // This condition will always return 'false' since the types '"a"' and '"b"' have no overlap.
  // Это условие всегда будет возвращать 'false' поскольку типы '"a"' и '"b"' не пересекаются.
  // Этот блок кода никогда не выполнится
}
```

## Типы как инструмент
TypeScript может обнаруживать ошибки, когда мы делаем ошибки в нашем коде. Это замечательно, но TypeScript может в первую очередь уберечь нас от этих ошибок.

Средство проверки типов содержит информацию, позволяющую проверять, например, получаем ли мы доступ к нужным свойствам переменных и другим свойствам. Получив эту информацию, он также может начать предлагать, какие свойства вы, возможно, захотите использовать.

Это означает, что TypeScript можно использовать и для редактирования кода, а основная программа проверки типов может выдавать сообщения об ошибках и автозавершение кода при вводе текста в редакторе. Это часть того, что люди часто имеют в виду, когда говорят об инструментах TypeScript.

![alt autosuggest](./images/autosuggest.png?raw=true "Autosuggest")

TypeScript серьезно относится к инструментам, и это выходит за рамки дополнений и ошибок при вводе. Редактор кода, поддерживающий TypeScript, может предоставлять «быстрые исправления» для автоматического исправления ошибок, рефакторинг для легкой реорганизации кода и полезные функции навигации для перехода к определениям переменной или поиска всех ссылок на данную переменную. Все это построено на основе проверки типов и является полностью кроссплатформенным, поэтому вполне вероятно, что ваш любимый редактор кода поддерживает TypeScript.

## tsc, компилятор TypeScript
Мы говорили о проверке типов, но еще не использовали этот инструмент. Давайте познакомимся с нашим новым другом `tsc`, компилятором TypeScript. Сначала нам нужно получить его через `npm`.
```
npm install -g typescript
```

<sub><sup>Это установит TypeScript компилятор `tsc` глобально. Вы можете использовать `npx` или аналогичные инструменты, если вместо этого предпочитаете запускать `tsc` из локального пакета `node_modules`.</sup></sub>

Теперь перейдем в пустую папку и попробуем написать нашу первую программу на TypeScript: `hello.ts`:
```TypeScript
// Выведем в консоль приветствие
console.log("Hello world!");
```
Заметьте, здесь нет никаких излишеств; эта программа «hello world» выглядит идентично тому, что вы написали бы для программы «hello world» на JavaScript. А теперь давайте проверим его тип, выполнив команду ], которая была установлена ​​для нас пакетом `typescript`.
```
tsc hello.ts
```
Мы запустили `tsc` и ничего не произошло! Что ж, ошибок типа не было, поэтому мы не получили никаких результатов в нашей консоли, так как не о чем было сообщать.

Но проверьте еще раз - вместо этого мы получили файл. Если мы заглянем в наш текущий каталог, мы увидим файл `hello.js` рядом с `hello.ts`. Это результат работы нашего файла `hello.ts` после того, как `tsc` скомпилирует или преобразует его в простой файл JavaScript. И если мы проверим содержимое, мы увидим, что выдаст TypeScript после обработки файла `.ts`:
```TypeScript
// Выведем в консоль приветствие
console.log("Hello world!");
```
В этом случае TypeScript было очень мало для преобразования, поэтому он выглядит идентично тому, что мы написали. Компилятор пытается создать чистый читаемый код, который выглядит так, как будто что-то написал бы человек. Хотя это не всегда так просто, TypeScript делает отступы единообразно, учитывает, когда наш код охватывает разные строки кода, и пытается сохранить комментарии.

А что насчет того, чтобы мы ввели ошибку проверки типов? Перепишем `hello.ts`:
```TypeScript
// Обычная функция приветствия
function greet(person, date) {
  console.log(`Hello ${person}, today is ${date}!`);
}

greet("Brendan");
```
Если мы снова запустим `tsc hello.ts`, обратите внимание, что мы получим ошибку в командной строке!
```TypeScript
Expected 2 arguments, but got 1.
```
TypeScript сообщает нам, что мы забыли передать аргумент в функцию `greet`, и это правильно. Пока что мы написали только стандартный JavaScript, но проверка типов все же смогла найти проблемы с нашим кодом. Спасибо, TypeScript!

### Вывод ошибок

Одна вещь, которую вы могли не заметить из последнего примера, - это то, что наш файл `hello.js` снова изменился. Если мы откроем этот файл, то увидим, что его содержимое в основном выглядит так же, как и наш входной файл. Это может быть немного удивительно, учитывая тот факт, что `tsc` сообщила об ошибке в нашем коде, но это основано на одной из основных ценностей TypeScript: в большинстве случаев вы будете знать лучше, чем TypeScript.

Повторяю сказанное ранее, код проверки типов ограничивает типы программ, которые вы можете запускать, и поэтому существует компромисс между тем, какие вещи для проверки типов будут сочтены приемлемыми. В большинстве случаев это нормально, но есть сценарии, когда эти проверки мешают. Например, представьте, что вы переносите код JavaScript на TypeScript и вводите ошибки проверки типов. В конце концов, вы придете к тому, чтобы навести порядок для средства проверки типов, но этот исходный код JavaScript уже работал! Почему преобразование его в TypeScript должно мешать вам запускать его?

Так что TypeScript вам не помешает. Конечно, со временем вы можете захотеть стать немного более защитной от ошибок и заставить TypeScript действовать немного строже. В этом случае вы можете использовать параметр компилятора `--noEmitOnError`. Попробуйте изменить свой файл `hello.ts` и запустить `tsc` с этим флагом:
```
tsc --noEmitOnError hello.ts
```
Вы заметите, что hello.js никогда не обновляется.

## Явные типы
До сих пор мы не сообщали TypeScript, что такое `person` или `data`. Давайте отредактируем код, чтобы сообщить TypeScript, что `person` - это `string`, а `date` является объектом `Date`. Мы также будем использовать метод `toDateString()` для `date`.
```TypeScript
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}
```
Что мы сделали, так это добавили аннотации типов к `person` и `date`, чтобы описать, с какими типами значений можно вызывать `greet`. Мы читаем сигнатуру функции `greet` как "`greet` принимает аргумент `person` типа `string` и аргумент `date` типа `Date`".

Благодаря этому TypeScript может рассказать нам о других случаях, когда мы могли вызвать функцию неправильно:
```TypeScript
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

greet("Maddison", Date());
// Argument of type 'string' is not assignable to parameter of type 'Date'.
```
TypeScript сообщил об ошибке во втором аргументе, но почему?

Как ни странно, вызов `Date()` в JavaScript возвращает строку. С другой стороны, создание `Date` с помощью `new Date()` фактически возвращает нам то, что мы ожидали.

В любом случае, мы можем быстро исправить ошибку:
```TypeScript
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

greet("Maddison", new Date());
```
Имейте в виду, что нам не всегда нужно писать явные аннотации типов. Во многих случаях TypeScript может даже просто вывести (infer) или вычислить типы за нас, даже если мы их опустим.
```TypeScript
let msg = "hello there!";
//  ^ = let msg: string
```
Несмотря на то, что мы не сообщили TypeScript, что у `msg` есть тип `string`, он смог это выяснить. Это фича TypeScript, и лучше не добавлять аннотации, если система типов может его вывести самостоятельно.

## Удаленные типы
Давайте посмотрим, что происходит, когда мы компилируем вышеуказанную функцию `greet` с помощью `tsc` для вывода JavaScript:
```JavaScript
"use strict";
function greet(person, date) {
    console.log("Hello " + person + ", today is " + date.toDateString() + "!");
}
greet("Maddison", new Date());
```
Обратите внимание на две вещи:
* Наши параметры `person` и `date` больше не имеют аннотаций типов.
* Наша «шаблонная строка» - та строка, в которой использовались обратные кавычки (символ `) - была преобразована в простые строки с помощью конкатенации (+).

Подробнее об этом втором пункте позже, а теперь давайте сосредоточимся на первом. Аннотации типов не являются частью JavaScript (или ECMAScript для точности), поэтому на самом деле нет браузеров или других сред выполнения, которые могли бы просто запускать TypeScript без изменений. Вот почему TypeScript в первую очередь нужен компилятор - ему нужен способ вырезать или преобразовать любой код, специфичный для TypeScript, чтобы вы могли его запустить. Большая часть кода, специфичного для TypeScript, стирается, а также стираются аннотации типов.

**Помните: аннотации типов никогда не меняют поведение вашей программы в рантайме.**

## Снижение версии
Еще одно отличие от приведенного выше заключалось в том, что наша строка шаблона была переписана с:
```TypeScript
`Hello ${person}, today is ${date.toDateString()}!`;
```
на:
```TypeScript
"Hello " + person + ", today is " + date.toDateString() + "!";
```
Почему это случилось?

Шаблонные строки - это функционал, добавленный в ECMAScript 2015 (также известной как ECMAScript 6, ES2015, ES6 и т. д.). TypeScript имеет возможность переписывать код из более новых версий ECMAScript в более старые, такие как ECMAScript 3 или ECMAScript 5 (также известные как ES3 и ES5). Этот процесс перехода от новой или «более высокой» версии ECMAScript к более старой или «более низкой» иногда называют понижением уровня (downleveling).

По умолчанию TypeScript компилирует в версию ES3, очень старую версию ECMAScript. Мы могли бы выбрать что-то более свежее, используя флаг `--target`. Запуск с `--target es2015` изменяет изменяет экспортируемую версию JavaScript на ECMAScript2015, что означает, что код должен работать везде, где поддерживается ECMAScript2015. Таким образом, запуск `tsc --target es2015 input.ts` дает нам следующий результат:
```JavaScript
function greet(person, date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}
greet("Maddison", new Date());
```
<sub><sup>Хотя целью по умолчанию является ES3, подавляющее большинство текущих браузеров поддерживают ES2015. Поэтому большинство разработчиков могут безопасно указать ES2015 или более позднюю версию в качестве цели, если не важна совместимость с некоторыми старыми браузерами.</sup></sub>
