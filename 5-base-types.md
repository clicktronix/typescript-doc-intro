# Базовые типы

Чтобы написанные программы корректно выполняли поставленные задачи, необходимо уметь работать с некоторыми из простейших единиц данных: числами, строками, логическими значениями и т. д. TypeScript поддерживает те же типы, что и JavaScript, с добавлением дополнительного типа перечисления (enum).

- **boolean** - самый базовый и примитивный тип данных, который может принимает значение true или false, то есть он может быть либо положительным, либо отрицательным. Также называется логическим типом данных. Из-за не явной типизации в JavaScript такая запись `Boolean(1)` будет возвращать `true`, а такая `Boolean(0)` вернет `false`.
  ```TypeScript
  const isDone: boolean = false;
  ```
- **number** - числовой тип данных. Как и в JavaScript, все числа в TypeScript являются либо значениями с плавающей запятой (float), либо BigInteger. Числа с плавающей запятой являются типом `number`, а BigInteger - принимают тип `bigint`. В дополнение к шестнадцатеричным и десятичным литералам TypeScript также поддерживает двоичные и восьмеричные литералы, представленные в ECMAScript 2015.
  ```TypeScript
  const decimal: number = 6;
  const hex: number = 0xf00d;
  const binary: number = 0b1010;
  const octal: number = 0o744;
  const big: bigint = 100n;
  ```
- **string** - строковый тип. Фундаментальная часть создания программ на JavaScript для веб-страниц и серверов - это работа с текстовыми данными. Как и в других языках, мы используем тип `string` для обозначения текстовых данных. TypeScript использует двойные или одинарные кавычки ("/') для окружения строковых данных (запись в виде литерала). Также можно использовать шаблонные строки (template strings), которые могут охватывать несколько строк и содержать встроенные выражения. Эти строки окружены символом обратной кавычки (`), а встроенные выражения имеют форму ${expr}.
  ```TypeScript
  const color: string = "blue";
  color = 'red';
  const fullName: string = `Bob Bobbington`;
  const age: number = 37;
  const sentence: string = `Hello, my name is ${fullName}.

  I'll be ${age + 1} years old next month.`;
  ```
- **null и undefined** - в TypeScript оба этих типа именуются также `undefined` и `null`. Как и `void`, сами по себе они не особо полезны:
  ```TypeScript
  const u: undefined = undefined;
  const n: null = null;
  ```
  По умолчанию `null` и `undefined` являются подтипами всех других типов. Это означает, что вы можете присвоить `null` или `undefined`, например, числу.
  Однако при использовании флага `--strictNullChecks` значения `null` и `undefined` могут быть присвоены только типам `unknown`, `any` и производным от них типам (есть одно исключение - значение `undefined` может быть присвоено типу `void`).
  Это помогает избежать многих распространенных ошибок. В случаях, когда вы хотите передать либо `string`, либо `null`, либо `undefined`, вы можете использовать тип объединения (union) в таком виде `string | null | undefined`. Но лучше не допускать, чтобы переменная могла принимать значения `null` и `undefined` одновременно, это может грозить непредвиденным поведением в дальнейшем.
- object - объект это составной тип. Объект выглядит как структура из пар { ключ: значение }. Значения могут быть любым примитивным типом (`string, number, boolean, null` и т.д), а также любым другим объектом. Object - является конструктором, который предоставляет API, методы для работы с объектами и манипуляции ими.
- array - массив, упорядоченная коллекция данных, в которой присутствуют 1-й, 2-й ... n-й элементы. Элементы, как и в объекте, могут быть любого типа. Но TypeScript разрешает добавлять в массив элементы только единого типа (исключением являются кортежи, производные от массивов). Типы массивов можно записать двумя разными способами. В первом используется тип элементов, которыми наполнен массив, за которым следует символ []:
  ```TypeScript
  const list: number[] = [1, 2, 3];
  ```
  Второй способ использует универсальный (generic) тип массива `Array<elemType>`:
  ```TypeScript
  const list: Array<number> = [1, 2, 3];
  ```
- **tuple** - тип кортеж. Кортежи позволяют выразить массив с фиксированным числом элементов, типы которых известны, но не обязательно должны быть одинаковыми. Например, вы можете представить значение как пару строки и числа:
  ```TypeScript
  // Задаем тип кортежа
  const x: [string, number];
  // Инициализируем его с корректными данными
  x = ["hello", 10];
  // Инициализируем с не корректными данными
  x = [10, "hello"]; // Ошибка
  // Type 'number' is not assignable to type 'string'.
  // Type 'string' is not assignable to type 'number'.
  ```
  При доступе к элементу с известным индексом извлекается правильный тип:
  ```TypeScript
  // OK
  console.log(x[0].substring(1));
  // Property 'substring' does not exist on type 'number'.
  console.log(x[1].substring(1));
  ```
  Доступ к элементу вне набора известных индексов завершается ошибкой:
  ```TypeScript
  x[3] = "world";
  // Tuple type '[string, number]' of length '2' has no element at index '3'.
  ```
- **enum** - тип перечисления. Новый тип, появившийся только в TypeScript. В таких языках, как C#, перечисление - это способ дать более понятные имена наборам числовых значений.
  ```TypeScript
  enum Color {
    Red,
    Green,
    Blue,
  }
  let c: Color = Color.Green;
  ```
  По умолчанию перечисления начинают нумерацию своих элементов с 0. Но значения каждого из элементов можно задавать в ручную. Например, мы можем начать предыдущий пример с 1 вместо 0 или даже вручную установить все значения в enum:
  ```TypeScript
  enum Color {
    Red = 1,
    Green,
    Blue,
  }
  const c: Color = Color.Green;
  // можно также обращаться к элементам через числовое значение, которое присвоено этому элементу
  const b: string = Color[1];
  ```
- **any** - в некоторых ситуациях доступна не вся информация о типе или нет возможности задать этот тип:
  ```TypeScript
  declare function getValue(key: string): any;
  // OK, возвращаемое значение не определено, может быть любого типа
  const str: string = getValue("myString");
  ```
  Тип `any` - это мощный способ работы с существующим JavaScript, позволяющий постепенно включать и отключать проверку типов во время компиляции. НО, помните, что все удобство достигается за счет потери безопасности типов. Безопасность типов - одна из основных причин использования TypeScript, и вы должны стараться избегать использования `any`, когда это не нужно.
- **void** - `void` чем-то похож на противоположность `any`: полное отсутствие какого-либо типа (пустота). Вы можете часто видеть это как возвращаемый тип функций, которые не возвращают значение:
  ```TypeScript
  function warnUser(): void {
    console.log("Функция возвращает void");
  }
  ```
  Объявление переменных типа `void` бесполезно, потому что вы можете присвоить им только значение `null` (только если `--strictNullChecks` не указано в конфигурации компилятора) или `undefined`:
  ```TypeScript
  const unusable: void = undefined;
  unusable = null;
  ```
- **never** - тип never представляет собой тип значений, которые никогда не встречаются. Например тип `never` будут возвращать функции, которые выбрасывают исключение (`throw new Error()`) или возвращают его. Переменные также получают тип `never`, когда проверяются специальными функциями для проверки типа type-guards, и если переменная не проходит проверку на нужный тип, то она получает тип `never`.
Тип never является подтипом каждого типа и может быть ему назначен; однако ни один тип не является подтипом `never` и не присваивается ему (кроме самого себя). Даже тип `any` не может быть назначен типу `never`.
  ```TypeScript
  // У функции возвращающей throw Error нет конкретного возвращаемого значения
  function error(message: string): never {
    throw new Error(message);
  }

  // Возвращаемый тип будет never
  function fail() {
    return error("Something failed");
  }

  // У функции возвращающей throw Error нет конкретного возвращаемого значения
  function infiniteLoop(): never {
    while (true) {}
  }
  ```
- **unknown** - может появиться необходимость описать тип переменных, о которых мы ничего не знаем на момент написания приложение. Значения этих переменных могут поступать из места, которое возвращает динамические данные - например, от пользователя. В этих случаях мы хотим предоставить тип, который сообщает компилятору и разработчикам, что эта переменная может быть чем угодно, поэтому мы даем ей неизвестный тип.
  ```TypeScript
  const notSure: unknown = 4;
  notSure = "Может быть строкой";

  // OK, точно булевое значение
  notSure = false;
  ```
  Если у вас есть переменная с типом `unknown`, вы можете сузить ее значения до чего-то более конкретного, выполнив проверки типа через `typeof`, проверки сравнения или более сложные меры защиты типов (type-guards):
  ```TypeScript
  declare const maybe: unknown;
  // 'maybe' может быть string, object, boolean, undefined, или другими, более сложными типами
  const aNumber: number = maybe;
  // Type 'unknown' is not assignable to type 'number'.
  // Type 'unknown' is not assignable to type 'number'.
  if (maybe === true) {
    // TypeScript теперь знает, что maybe может быть булевой переменной
    const aBoolean: boolean = maybe;
    // Но не может быть строкой
    const aString: string = maybe;
    // Type 'boolean' is not assignable to type 'string'.
    // Type 'boolean' is not assignable to type 'string'.
  }

  if (typeof maybe === "string") {
    // TypeScript теперь знает, что maybe может быть строковой переменной
    const aString: string = maybe;
    // Но не может быть булевой
    const aBoolean: boolean = maybe;
    // Type 'string' is not assignable to type 'boolean'.
    // Type 'string' is not assignable to type 'boolean'.
  }
  ```
- **Про ключевые слова Number, String, Boolean, Symbol и Object** - может возникнуть соблазн подумать, что это типы и они совпадают с версиями в нижнем регистре, рекомендованными выше. Однако эти конструкции не относятся к языковым примитивам и почти никогда не должны использоваться как тип. Это конструкторы, с помощью которых можно создавать примитивы:
  ```TypeScript
  const n: number = new Number("1234"); // создаст число 1234
  ```
  Вместо них всегда используйте `number`, `string`, `boolean`, `object` и `symbol`. 
